\chapter{Developer Guide}

The chapter is work in progress.  It is not meant for user of the
\Vauc library, but to developer and contributor who wish to include
code in \Vauc.

\section{Contributing Code}
\label{sec:contributing-code}



\subsection{Coding Style}

Until this is written, please refer to
\href{http://www.lrde.epita.fr/~akim/compil/assignments.split/Coding-Style.html#Coding-Style}{Tiger's
  Coding Style}.


\subsection{Writing Algorithms}

There is a number of requirement to be met before including an
algorithms into the library:
\begin{description}
\item[Document the algorithm] Besides the usual interface description,
  the Doxygen documentation must include:
  \begin{itemize}
  \item references to the definitions of the algorithm, e.g., a
    reference to the ``Éléments de la théorie des automates'', or even
    an URL to a mailing-list archive.
  \item detailed description of the assumptions, or, if you wish, pre-
    and post-conditions.
  \item the name of the developer
  \end{itemize}

\item[Comment the code] Especially if the code is a bit tricky, or
  smart, or avoids nasty pitfalls, it \emph{must} be commented.

\item[Bind the algorithm to \tafkit]

\item[Include tests] See \autoref{sec:writing-tests} for more
  details.  Tests based on \tafkit are appreciated.  Note that tests
  require test cases: to exercise an algorithm, not any automaton will
  do, try to find relevant samples.  Again, ETA is a nice source of
  inspiration.

\item[Complete the documentation]  The pre- and post-conditions should
  also be described here.
\end{description}

When submitting a patch, make it complete (i.e., including the
aforementioned items), and provide a ChangeLog.  See
\href{http://www.lrde.epita.fr/dload/guidelines/guidelines.html}{Le
  Guide du \lrde}, section ``La maintenance de projets'' and
especially ``Écrire un ChangeLog'' for more details.

Because \Vauc uses Trac, ChangeLog entries should explicit refer to
tickets (e.g., ``Fixing issue \#38: implement is\_ambiguous''), and
possible previous revisions (e.g., ``Fix a bug introduced in
[1224]'').

\subsection{Writing Tests}
\label{sec:writing-tests}


\subsection{Mailing Lists}
\label{sec:mailing-lists}

\Vauc comes with a set of mailing lists:
\begin{description}
\item[vaucanson@lrde.epita.fr] General discussions, feature request etc.
\item[vaucanson-bugs@lrde.epita.fr] To report errors in code,
  documentation, web pages, etc.
\item[vaucanson-patches@lrde.epita.fr] To submitted patches on code,
  documentation, and so forth.
\item[vaucanson-private@lrde.epita.fr] To contact privately the
  \Vauc team.
\end{description}

Please, bear in mind that there are these lists have many readers,
therefore this is a WORM medium: Write Once, Read Many.  As a
consequence:
\begin{itemize}
\item Be complete.\\
  One should not strive to understand what you are referring to, so
  always include proper references: URLs, Ticket numbers \emph{and
    summary}, etc.
\item Be concise.\\
  Write short, spell checked, understandable sentences.  Reread
  yourself, remove useless words, be proud of what you wrote.  Show
  respect to the reader.  Spare us useless messages.
\item Be structured.\\
  Quick and dirty replies with accumulated layers of replies at the
  bottom of the message is not acceptable.  The right ordering is not
  the one that is the quickest to write, but the easiest to read.
\item Be attentive.\\
  Lists are not write-only: consider the feedback that is given with
  respect.
\end{itemize}

As an example of what's not to be done, avoid answering to yourself to
point out you made a spell mistake: we can see that, and that's a
waste of time to read another message for that.  Also, there is no
hurry, it would probably be better to wait a bit to have a complete,
well thought out, message, rather than a thread of 4 messages
completing, contradicting, each other.  Finally, if you still need to
fix your message, supersede it, or even cancel it.

\section{Vaucanson I/O}
\label{sec:vaucanson-io}

January 2005

Here is some information about input and output of automata in
\href{http://www.lrde.epita.fr/vaucanson}{Vaucanson}.

\subsection{Introduction}

As usual, the structure of the data representing an automaton in a flat
file is called the file format.

There are several input and output formats for Vaucanson
automata. Obviously:
\begin{itemize}
\item {}
input formats are those that can be read from, i.e. from which an
automaton can be loaded.

\item {}
output formats are those that can be written to, i.e. to which an
automaton can be dumped.

\end{itemize}

Given these definitions, here is the meat:
\begin{itemize}
\item {}
Vaucanson supports Graphviz (dot) as an output format. Most kinds of
automata can be dumped as dot-files. Through the library this format
is simply called \texttt{dot}.

\item {}
Vaucanson supports XML as an input and output format. Most kinds of
automata can be read and written to and from XML streams, which
Vaucanson does by using the Xerces-C++ library. Through the library
this format is simply called \texttt{xml}.

\item {}
Vaucanson supports the FSM toolkit I/O format as an input and output
format. This allows for basic FSM interaction. Only certain kinds of
weighted automata can be meaningfully input and output with this
format. Through the library this format is simply called \texttt{fsm}.

\item {}
Vaucanson supports a simple informative textual format as an input
and output format. Most kinds of automata can be read and written to
and from this format. Through the library this format is simply called
\texttt{simple}.

\end{itemize}


%___________________________________________________________________________

\subsection{Dot format}

This format provides an easy way to produce a graphical representation
of an automaton.

Output using this format can be given as input to the Graphviz \texttt{dot}
command, which can in turn produce graphical representations in
Encapsulated PostScript, PNG, JPEG, and many others.

It uses Graphviz' ``directed graph'' subformat.

If you want to see what it looks like go to the
\texttt{src/demos/automaton{\_}library} subdirectory, build the examples and run
them with the ``dot'' argument.

For Graphviz users:

Each graph generated by Vaucanson can be named with a string that also
prefixes each state name. If done so, several automata can be grouped
in a single graph by simply concatenating the Vaucanson outputs.


%___________________________________________________________________________

\subsection{XML format}

This format is intended to be an all-purpose strongly typed input and
output format for automata.

Using it requires:
\begin{itemize}
\item {}
that the Xerces-C++ library is installed and ready to use by the C++
compiler that is used to compile Vaucanson.

\item {}
configuring Vaucanson to use XML.

\item {}
computer resources and time.

\end{itemize}

What you gain:
\begin{itemize}
\item {}
support for the Greater and Better I/O format. See documentation in
the \texttt{doc/xml} subdirectory for further information.

\end{itemize}

If you want to see what it looks like go to the
\texttt{src/demos/automaton{\_}library} subdirectory, build the examples and run
them with the \texttt{xml} argument.


%___________________________________________________________________________

\subsection{FSM format}

This format is intended to provide a basic level of compatibility with
the FSM tool kit. (FIXME: references needed)

Like FSM, support for this format in Vaucanson is limited to
deterministic automata. It probably does not work with transducers,
either.

It is not meant to be used that much apart from performance comparison
with FSM. Some code exists to simulate FSM, in
\texttt{src/demos/utilities/fsm}.

If you want to see what it looks like go to the
\texttt{src/demos/automaton{\_}library subdirectory}, build the examples and run
them with the \texttt{fsm} argument.


%___________________________________________________________________________

\subsection{Simple format}

Initially intended to be a quick and dirty debugging input and output
format, this format actually proves to be a useful, compact and
efficient textual representation of automata.

Advantages over XML:
\begin{itemize}
\item {}
does not require additional 3rd party software,

\item {}
simple and efficient (designed to be read and written to streams
with very low memory footprint and minimum complexity),

\item {}
less bytes in file,

\item {}
not strongely typed (can be dumped from one automaton type and
loaded to another).

\end{itemize}

Drawbacks from XML:
\begin{itemize}
\item {}
not strongely typed (one cannot know what automaton type to build by
only looking at the raw data).

\item {}
currently does not (probably) support transducers.

\end{itemize}

If you want to see what it looks like go to the
\texttt{src/demos/automaton{\_}library subdirectory}, build the examples and run
them with the \texttt{simple} argument.


%___________________________________________________________________________

\subsection{Using input and output}

The library provides an infrastructure for generic I/O, which
(hopefully) will help supporting more formats in the future.

The basis for this infrastructure is the way a developer C++ using the
library will use it:
\begin{quote}{\ttfamily \raggedright \noindent
{\#}include~<vaucanson/tools/io.hh>~\\
~\\
/*~to~save~an~automaton~*/~\\
output{\_}stream~<{}<~automaton{\_}saver(automaton,~converter,~format)~\\
~\\
/*~to~load~an~automaton~*/~\\
input{\_}stream~>{}>~automaton{\_}loader(automaton,~converter,~format,~merge{\_}states)
}\end{quote}

Where:
\begin{itemize}
\item {}
\texttt{automaton} is the automaton undergoing input or output. Note that
the object must already be constructed, even to be read into.

\item {}
\texttt{converter} is a helper class that is able to convert automaton
transitions to character strings and possibly vice-versa.

\item {}
\texttt{format} is a helper class that is able to convert the automaton
to (and possibly from) a character string, using the converter as an
argument.

\item {}
\texttt{merge{\_}states} is an optional argument that should be omitted in
most cases. For advanced users, it allows loading a single automaton
from several different streams that share the same state set.

\end{itemize}


%___________________________________________________________________________

\subsubsection{About converters}

The \texttt{converter} argument is mandatory. There are several converter
types already available in Vaucanson. See below.

An I/O converter is a function object with one or both of the following:
\begin{itemize}
\item {}
an operation that takes an automaton, a transition label and
converts the transition label to a character string
(std::string). This is called the output conversion.

\item {}
an operation that takes an automaton, a character string and
converts the character string to a transition label. This is called
the input conversion.

\end{itemize}

Vaucanson already provides these converters:
\begin{description}
%[visit_definition_list_item]
\item[{\texttt{vcsn::io::string{\_}out}, bundled with \texttt{io.hh}.}] %[visit_definition]

Provides the output conversion only. Uses the C++ operator {\textless}{\textless} to
create a textual representation of transition labels. Should work
with all label types.

%[depart_definition]
%[depart_definition_list_item]
%[visit_definition_list_item]
\item[{\texttt{vcsn::io::usual{\_}converter{\_}exp}, defined in \texttt{tools/usual{\_}io.hh}.}] %[visit_definition]

Provides both input and output conversions. Uses the C++ operator {\textless}{\textless}
to create a textual representation of transition labels, but
requires also that algebra::parse can read back that representation
into a variable of the same type. It is mostly used for generalized
automata where transitions are labeled by rational expressions,
hence the name.

%[depart_definition]
%[depart_definition_list_item]
%[visit_definition_list_item]
\item[{\texttt{vcsn::io::usual{\_}converter{\_}poly<ExpType>}, defined in \texttt{tools/usual{\_}io.hh}.}] %[visit_definition]

Provides both input and output conversions. Converts transition labels
to and from ExpType before (after) doing I/O. The implementation
is meant to be used when labels are polynoms, and using the
generalized (expression) type as ExpType.

%[depart_definition]
%[depart_definition_list_item]
\end{description}


%___________________________________________________________________________

\paragraph{Notes about XML and converters}

When the XML I/O format was implemented, the initial converter system
was not used. Instead a specific converter system was re-designed
specifically for this format.

(FIXME: explain why!)

(FIXME: why hasn't the generic converter for XML been ported back to
fsm and simple formats?)

Because of this, when using XML I/O the ``converter'' argument is
completely ignored by the format processor. Usually you can see
\texttt{vcsn::io::string{\_}output} mentioned.

(FIXME: this is terrible! it must be patched to use an empty
vcsn::io::xml{\_}converter{\_}placeholder or something like it).


%___________________________________________________________________________

\subsubsection{About formats}

The \texttt{format} argument is mandatory. It specifies an instance of the
object in charge of the actual input or output.

A format object is a function object that provides one or both the
following operations:
\begin{itemize}
\item {}
an operation that takes an output stream, the caller \texttt{automaton{\_}saver}
object, and the \texttt{converter} object. This is called the output operation.

\item {}
an operation that takes an input stream and the caller
\texttt{automaton{\_}loader} object. This is called the input operation.  Note
that this operation does not uses the \texttt{converter} object, because
it should call back the \texttt{automaton{\_}loader} object to actually perform
string to transition label conversions.

\end{itemize}

Format objects may require arguments to be constructed, such as the
title of the automaton in the output.

Format objects for a format should be defined in a
\texttt{tools/xxx{\_}format.hh} file.

Vaucanson already provides the following format objects:
\begin{description}
%[visit_definition_list_item]
\item[{\texttt{vscn::io::dot(const std::string{\&} digraph{\_}title)}, in \texttt{tools/dot{\_}format.hh}.}] %[visit_definition]

Provides an output operation for the Graphviz \texttt{dot} subformat. The title
provided when buildint the \texttt{dot} object in Vaucanson becomes the title
of the graph in the output data and a prefix for state names. Therefore
the title must contain only alphanumeric characters or the underscore ({\_}),
and no spaces.

%[depart_definition]
%[depart_definition_list_item]
%[visit_definition_list_item]
\item[{\texttt{vcsn::io::simple()}, in \texttt{tools/simple{\_}format.hh}.}] %[visit_definition]

Provides both input and output operations for a simple text format.

%[depart_definition]
%[depart_definition_list_item]
%[visit_definition_list_item]
\item[{\texttt{vcsn::xml::XML(const std::string{\&} xml{\_}title)}, in \texttt{xml/XML.hh}.}] %[visit_definition]

Provides both input and output operations for the Vaucanson XML I/O format.

%[depart_definition]
%[depart_definition_list_item]
\end{description}

(FIXME: why not tools/xml{\_}format.hh with proper includes of headers in xml/?)

(FIXME: really the FSM format should have a format object too.)


%___________________________________________________________________________

\subsection{Examples}

Create a simple dot output for an automaton a1:
\begin{quote}{\ttfamily \raggedright \noindent
std::ofstream~fout("output.dot");~\\
fout~<{}<~automaton{\_}saver(a1,~vcsn::io::string{\_}output(),~vcsn::io::dot("a1"));~\\
fout.close()
}\end{quote}

Output automaton a1 to XML, read it back into another automaton a2
(possibly of another type):
\begin{quote}{\ttfamily \raggedright \noindent
std::ofstream~fout("file.xml");~\\
fout~<{}<~automaton{\_}saver(a1,~NULL,~vcsn::xml::XML());~\\
fout.close()~\\
~\\
std::ifstream~fin("file.xml");~\\
fin~>{}>~automaton{\_}loader(a2,~NULL,~vcsn::xml::XML());~\\
fin.close()
}\end{quote}

Do the same, but this time using the simple format. The automata are
generalized, i.e. labeled by expressions:
\begin{quote}{\ttfamily \raggedright \noindent
std::ofstream~fout("file.txt");~\\
fout~<{}<~automaton{\_}saver(a1,~vcsn::io::usual{\_}converter{\_}exp(),~vcsn::io::simple());~\\
fout.close()~\\
~\\
std::ifstream~fin("file.txt");~\\
fin~>{}>~automaton{\_}loader(a2,~vcsn::io::usual{\_}converter{\_}exp(),~vcsn::io::simple());~\\
fin.close()
}\end{quote}


%___________________________________________________________________________

\subsection{Internal scenario}

What happens in Vaucanson when you write:
\begin{quote}{\ttfamily \raggedright \noindent
fin~>{}>~automaton{\_}loader(a1,~c1,~f1)
}\end{quote}

?
\newcounter{listcnt1}
\begin{list}{\arabic{listcnt1}.}
{
\usecounter{listcnt1}
\setlength{\rightmargin}{\leftmargin}
}
\item {}
function \texttt{automaton{\_}loader} creates an object AL1 of type
\texttt{automaton{\_}loader{\_}} that memorizes its arguments.

\item {}
\texttt{automaton{\_}loader()} returns AL1.

\item {}
\texttt{operator>{}>(fin, AL1)} is called.

\item {}
\texttt{operator>{}>} says to format object f1: ``hi, please use fin to load
something with AL1''.

\item {}
f1 scans input stream fin. Things may happen then:

\end{list}
\begin{quote}
\begin{itemize}
\item {}
f1 finds a state numbered N. Then it says to AL1: ``hey, make a new
state into the output automaton, keep its handler s1 for yourself
and remember it is associated to N''.  (callback \texttt{AL1.add{\_}state})

\item {}
f1 finds a transition from state numbered N to state P, labeled
with character string S. Then it says to AL1: ``hey, create a
transition with N, P, and S.'' (callback \texttt{AL1.add{\_}transition}).
Then:
\begin{itemize}
\item {}
AL1 remembers handler for state N (s1)

\item {}
AL1 remembers handler for state P (s2)

\item {}
AL1 says to converter c1: ``hey, make me a transition label from S''

\item {}
AL1 creates transition from s1 to s2 using converted label into
output automaton.

\end{itemize}

\end{itemize}
\end{quote}

6. when f1 is finished, it returns control to \texttt{operator>{}>} and then
calling code.

Of course since everything is statically compiled using templates
there is no performance drawback due to the intensive use of
callbacks.


%___________________________________________________________________________

\subsection{Convenience utilities}

For most formats the (relatively) tedious following piece of code:
\begin{quote}{\ttfamily \raggedright \noindent
output{\_}stream~<{}<~automaton{\_}saver(a,~CONVERTER(),~FORMAT(...))
}\end{quote}

is also available as:
\begin{quote}{\ttfamily \raggedright \noindent
FORMAT{\_}dump(output{\_}stream,~a,~...)
}\end{quote}

If available, this convenience utility is defined in \texttt{tools/XXX{\_}dump.hh}.

Conversely, the following piece of code:
\begin{quote}{\ttfamily \raggedright \noindent
input{\_}stream~>{}>~automaton{\_}loader(a,~CONVERTER(),~FORMAT(...))
}\end{quote}

is usually also available as:
\begin{quote}{\ttfamily \raggedright \noindent
FORMAT{\_}load(input{\_}stream,~a,~...)
}\end{quote}

If available, this convenience utility is defined in \texttt{tools/XXX{\_}load.hh}.

(FIXME: move fsm{\_}load away from fsm{\_}dump.hh!)

As of today (2006-03-17) the FSM format is only available using the
fsm{\_}load() and fsm{\_}dump() interface.
% Local Variables:
% mode: rst
% End:

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "vaucanson-user-manual"
%%% End:
