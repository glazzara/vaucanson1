\documentclass[a4paper]{report}

\usepackage[american]{babel}
\usepackage[latin1]{inputenc}
\usepackage{a4wide}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{hyperref}
\usepackage{textcomp}
\usepackage{tabularx}
\usepackage{url}
\usepackage{graphicx}
\usepackage{xspace}

%% -------------------- %%
%% Tikz configuration.  %%
%% -------------------- %%

\usepackage{pgf,tikz}
\usetikzlibrary{automata}
\usetikzlibrary{arrows}
\tikzstyle{automaton}=[shorten >=1pt,
                       node distance=2cm,
                       pos=.4,
                       >=stealth',
                       every state/.style={draw,very thick,minimum size=7mm},
                       every edge/.style={draw,thick},
                       initial distance=7mm,
                       accepting distance=7mm,
                       initial text=]
\tikzstyle{loop right}=[right,out=25,in=-25,loop,pos=.5]
\tikzstyle{loop above}=[above,out=115,in=65,loop,pos=.5]
\tikzstyle{loop left}=[left,out=205,in=155,loop,pos=.5]
\tikzstyle{loop below}=[below,out=295,in=245,loop,pos=.5]
\tikzstyle{accepting}=[accepting by arrow]
\tikzoption{initial angle}{\tikzaddafternodepathoption{\def\tikz@initial@angle{#1}}}
\tikzoption{accepting angle}{\tikzaddafternodepathoption{\def\tikz@accepting@angle{#1}}}

%% ---------------------- %%
%% Mathematical symbols.  %%
%% ---------------------- %%
\renewcommand{\max}{\textrm{max}}
\renewcommand{\min}{\textrm{min}}
\newcommand{\Z}{\texorpdfstring{\ensuremath{\mathbb{Z}}}{Z}}
\newcommand{\B}{\texorpdfstring{\ensuremath{\mathbb{B}}}{B}}
\newcommand{\Ae}{\ensuremath{A^{*}}}
\newcommand{\SerSAnMon}[2]%
    {\ensuremath{#1 \langle \! \langle  #2  \rangle \! \rangle}}

\newcommand{\newcal}[1]{%
  \expandafter \newcommand \csname #1c\endcsname%
  {\texorpdfstring{\ensuremath{\mathcal{#1}}}{#1}}%
}
\newcal{A}
\newcal{B}
\newcal{C}
\newcal{T}

\newtheorem{theorem}             {Theorem}[chapter]
\newtheorem{definition} [theorem]{Definition}
\newtheorem{remark}     [theorem]{remark}

\makeatletter
\newcommand{\Cxx}{%
  \valign{\vfil\hbox{##}\vfil\cr
    {C\kern-.1em}\cr
    $\hbox{\fontsize\sf@size\z@\textbf{+\kern-0.05em+}}$\cr}%
    \xspace
}
\makeatother

\def\tikzname{Ti\emph{k}Z\xspace}

%% FIXME: it should be (#1,#2) for FMP transducers
% A transition for a transducer.
\newcommand{\IOL}[2]{#1\!\mid\! #2}

%% ------- %%
%% Index.  %%
%% ------- %%

% The same argument is output and put in the index.
\usepackage{makeidx}
\makeindex
\newcommand{\Index}[1]{\index{#1}#1}

\usepackage{listings}
\lstset{%
  numbers=left,
  numberstyle=\tiny,
  stepnumber=5,
  numbersep=5pt,
  firstnumber=1,
  basicstyle=\small,
  frame=single,
  language=C++,
  float}

% Document a figure.
\newenvironment{legend}{%
  \begin{quote}%
    }{%
  \end{quote}%
}

%% Display an interactive session.
\usepackage{alltt}
\newenvironment{shell}
{\begin{alltt}}
{\end{alltt}}

% @VcsnVersion@
\def\VcsnVersion{1.2.95a}

%% ----------------------- %%
%% Texinfo like commands.  %%
%% ----------------------- %%

\newcommand\kbd[1]{\textsl{\texttt{#1}}}
\newcommand\file[1]{`\texttt{#1}'}
\newcommand\command[1]{\texttt{#1}}
\newcommand\var[1]{{\ttfamily\itshape #1}}
\newcommand\code[1]{\texttt{#1}}
\newcommand\samp[1]{`\texttt{#1}'}
\newcommand\option[1]{`\texttt{#1}'}

%% -------------------- %%
%% Vaucanson commands.  %%
%% -------------------- %%

%% A TAF-kit function name (i.e., the first argument for TAF-Kit
%% programs).
\newcommand{\taffn}[1]{\code{#1}}
\newcommand{\tafkit}{\textsc{TAF-Kit}\xspace}
\newcommand{\Vauc}{\textsc{Vaucanson}\xspace}
%% Attach weights in a type writer environment.
\newcommand{\withweighttt}[2]{\symbol{`\{}#1\symbol{`\}} #2}

% \begin{fnsection}{NAME}
% -----------------------
% A group of taf-kit functions.
% Putting the ending hline in the end section is tempting, but fails.
\newenvironment{fnsection}[1]{%
  % \item{NAME}{ARGS}{DOC}
  % ----------------------
  % Define a taf-kit function.
  % We use \item because it has Emacs indentation support.
  \renewcommand{\item}[3]{\texttt{##1} \var{##2} & ##3\\}

  \tabularx{\textwidth}{|l|X|}%
    \hline\multicolumn{2}{|c|}{#1} \\\hline%
  }{%
  \endtabularx%
}

\def\manualtitle{\Vauc User's Manual}

%% ---------- %%
%% Document.  %%
%% ---------- %%
\begin{document}
\vspace*{50pt}
\vskip4pt \hrule height 4pt width \hsize \vskip4pt
\begin{center}
  \Huge \manualtitle
\end{center}
\vspace*{-1.5ex}
\vskip4pt \hrule height 4pt width \hsize \vskip4pt

\hfill compiled on \today, for version \VcsnVersion

\vfill

\setcounter{tocdepth}{2}
\makeatletter
\@starttoc{toc}
\makeatother

\vfill

\chapter*{Introduction}
\label{sec:intro}

\Vauc is a free software platform dedicated to the manipulation of
finite state automata.  Here, `finite state automata' is to be
understood in the broadest sense: \Vauc supports \emph{weighted}
automata over a free monoid, and even \emph{weighted} automata on some
\emph{non free monoids} (currently only products of free
monoids---a.k.a. transducers---are supported).

The platform consists in a couple of components:
\begin{description}
\item[The \Vauc library] is a \Cxx library that implements objects for
  automata, rational expressions, as well as algorithms on these
  objects.  This library is generic, in the sense that it makes it
  possible to write an algorithm once and apply it to different types
  of automata.  However this genericity is achieved in a way that
  should not cause any slowdown at runtime: because the type of the
  automata manipulated is known at compile time, compiling an
  algorithm will generate code that is almost as efficient as an
  algorithm dedicated to this type of automaton.

\item[\tafkit] is a command-line interface to the library, that allows
  user to execute \Vauc's algorithms without any knowledge of \Cxx.
  Because the \Vauc library needs to know the type of automata at
  compile time, the \tafkit interface has been instantiated for a
  predefined set of common automaton types.

  \tafkit does not allow to write new algorithms nor to manipulate new
  types of automata, but it makes it possible to combine without
  efforts a large set of algorithms on common automata types.

\item[A repository of automata] that shows examples of automata of
  various types, and also contains tools to create families of
  automata.
\end{description}

Ideally this manual should document all of these components.
Presently it only documents \tafkit because that is the more
accessible part of \Vauc.


\chapter{Administrativia}

\section{Getting \Vauc}

The latest version of the \Vauc platform can be downloaded from
\url{http://vaucanson.lrde.epita.fr/}.

\section{Licensing}

Vaucanson is a free software released under the GNU General Public
Licence version 2. If you are unfamiliar with this license, please
read the file \file{COPYING} (at the root of the source tree) for
details.

\section{Building \Vauc}

Detailed information is provided in the files \file{INSTALL}, which is
generic to all packages using the GNU Build System, and
\file{doc/README.pdf} which details \Vauc's specific build process.
The typical installation commands will install \Vauc in
\file{/usr/local/}.

\begin{shell}
$ \kbd{cd vaucanson-\VcsnVersion}
$ \kbd{./configure}
$ \kbd{make}
$ \kbd{sudo make install}
\end{shell}

Although we discourage it, you may also use \Vauc without installing
it: you would have to use \kbd{-I
  /full-path-to/vaucanson-\VcsnVersion/include} when compiling C++
programs, and move to directory
\file{vaucanson-\VcsnVersion/taf-kit/tests/} to execute \tafkit.  (The
\file{taf-kit/tests/} directory contains wrapper around the real
\tafkit programs from \file{taf-kit/tests/} that enable them to run
locally.)

\section{Getting in Touch}

Please send any question or comments to \url{vaucanson@lrde.epita.fr}, and
report bugs to either our issue tracker at \url{http://vaucanson.lrde.org/} or
by mailing \url{vaucanson-bugs@lrde.epita.fr}.

You can subscribe to these mailing lists at
\url{https://www.lrde.epita.fr/cgi-bin/mailman/listinfo/vaucanson} and
\url{https://www.lrde.epita.fr/cgi-bin/mailman/listinfo/vaucanson-bugs}
if you like, but this is not a requirement for sending mails.

\chapter{The \Vauc toolkit}
\label{sec:tafkit}

This chapter presents a simple interface to \Vauc: a set of programs
tailored to be used from a traditional shell.  Since they exchange
\emph{typed} XML files, there is one program per automaton type.  Each
program supports a set of operations which depends on the type of the
automaton.

Many users of automata consider only automata whose transitions are
labeled by letters taken in an alphabet, which we call, roughly
speaking, \emph{classical} automata or \emph{Boolean} automata.  The
first program of the \tafkit, \command{vcsn-char-b}, allows to compute
with classical automata and is described in \autoref{sec:vcsn-char-b}.
A variant of this program called \command{vcsn-int-b} handles Boolean
automata whose letters are integers.

\autoref{sec:vcsn-char-fmp-b} describes the program
\command{vcsn-char-fmp-b} which allows to compute with transducers, that
is, automata whose transitions are labeled by pair of words, which are
elements of a \emph{product of free monoids}, hence the name.  A
variant of this program called \command{vcsn-int-fmp-b} handles
transducers whose letters are integers.

In \autoref{sec:vcsn-char-z} we consider the programs of the \tafkit
that compute with automata over a free monoid and with multiplicity,
or \emph{weight} taken in the set of integers equipped with the usual
operations of addition and multiplication, that is, the semiring $\Z$.
A variant of this program called \command{vcsn-int-z} is specialized
to handle $\Z$-automata whose letters are integers.

% ,
% or with the operations of $\min$ and addition, or the operations of
% $\max$ and addition, that is, the semirings $\Z,\min,+$ and
% $\Z,\max,+$.  Finally, the forth section describes the program
% \command{vcsn-char-rw} which allows to compute with transducers, viewed
% as automata on a free monoid (the input monoid) with multiplicity
% taken in the semiring of finite and even rational subsets of another
% free monoid (the output monoid).

\medskip


It is planned that a forthcoming version will include also:

\begin{description}
\item[vcsn-char-zmin] for automata over a free monoid with multiplicity in
  the semiring (\Z, \min, +)

\item[vcsn-char-zmax] for automata over a free monoid with multiplicity in the
  semiring (\Z, \max, +)

\item[vcsn-char-rw] for transducers viewed as automata over a free
  monoid with multiplicity in the semiring of rational sets (or
  series) over (another) free monoid.
\end{description}

\newpage

\section{Boolean automata}
\label{sec:vcsn-char-b}

This section focuses on the program \Index{\command{vcsn-char-b}}, the
\tafkit component dedicated to Boolean automata.

\subsection{First Contacts}

\command{vcsn-char-b} and its peer components of \tafkit all share the same
simple interface:

\begin{shell}
$ vcsn-char-b \var{function} \var{automaton} \var{arguments...}
\end{shell}

\noindent
The \var{function} is the name of the operation to perform on the
\var{automaton}, specified as an XML file.  Some functions, such as
\taffn{evaluation}, require additional arguments, such as the word to
evaluate.  Some others, such as \taffn{exp-to-aut} do not have an
\var{automaton} argument.

\tafkit is made to work with Unix \emph{pipes}, that is to say, chains
of commands which feed each other.  Therefore, all the functions
produce a result on the standard output, and if an \var{automaton} is
\samp{-}, then the standard input is used.

\smallskip

A typical line of commands from the \tafkit reads as follows:
\begin{shell}
$ \kbd{vcsn-char-b determinize-nodep a1.xml > a1det.xml}
\end{shell}
and should be understood, or analyzed, as follows.
\begin{enumerate}
\item \command{vcsn-char-b} is the call to a \command{shell} command
  that will launch a \Vauc function.  \command{vcsn-char-b} has 2
  arguments, the first one being the \var{function} which will be
  launched, the second being the \var{automaton} that is the input
  argument of the \var{function}.

\item \taffn{determinize} is, as just said, a \Vauc function.  And as
  it can easily be guessed, \taffn{determinize} takes an
  \var{automaton} as argument, performs the subset construction on it
  and outputs the result on the standard output.

\item \file{a1.xml} is the description of an automaton --- of the
  automaton of \autoref{char-b:a1} indeed --- in an XML format that is
  understood\footnote{%
    This format is not exactly part of the \Vauc platform.  It has
    been developed for providing a means of communication between
    various programs dealing with automata.  And then it has been used
    as a communication tool between the invocations of \Vauc function
    by the \tafkit.  A lay user of the \tafkit should not need to know
    how this format is defined
    but a rough description of it is provided in \autoref{sec:xml} of
    the Appendix.}
  by \Vauc. This file must exist before the line is executed.  The
  \file{data/automata} directory provides a number of XML files for
  examples of automata, a number of programs that produce the XML
  files for automata whose definition depend upon some variables and
  the \tafkit itself allows to define automata and thus to produce the
  corresponding XML files (cf. below).

\item \samp{>a1det.xml} puts the result of \taffn{determinize} into
  the file \file{a1det.xml}, that is, the XML file which describes the
  determinized automaton of $\Ac_{1}$.
\end{enumerate}

\bigskip

As a more elaborate example, consider the following command

\begin{shell}
$ \kbd{vcsn-char-b identity-nodep a1.xml | vcsn-char-b determinize - | vcsn-char-b minimize - | vcsn-char-b info -}
\end{shell}

\noindent
It fetches the automaton \code{a1} from the automaton library,
determinizes it, minimizes the result, and finally displays
information about the resulting automaton.

Please, note the typographic conventions: user input is represented
\texttt{\# \kbd{like this}}, standard output follows \texttt{like
  this}, followed by standard error output \texttt{error: like this},
and finally, if different from 0, the exit status is represented
\texttt{=> like this}.  For instance:

\begin{shell}
$ \kbd{vcsn-char-b identity-nodep a1.xml | vcsn-char-b info -}
\end{shell}

\smallskip

Other than that, the interface of the \tafkit components is usual,
including options such as \option{--version} and \option{--help}:

\begin{shell}
$ \kbd{vcsn-char-b --help}
\end{shell}

The whole list of supported commands is available via
\option{--list-commands}.

\subsection{A first example}

\Vauc provides a set of common automata.  The function
\Index{\taffn{list-automata}} lists them all:

\begin{shell}
$ \kbd{vcsn-char-b list-automata}
\end{shell}

\begin{figure}[ht] \centering
  \begin{tikzpicture}[automaton]
    % states
    \node[state, initial] (A) at (0,0) {};
    \node[state] (B) at (3,0) {};
    \node[state, accepting] (C) at (6,0) {};
    % initial--final
    % transitions
    \path[->] (A) edge node[above] {$a$} (B);
    \path[->] (B) edge node[above] {$b$} (C);
    \path[->] (A) edge [loop below] node[below] {$b$} (A);
    \path[->] (A) edge [loop above] node[above] {$a$} (A);
    \path[->] (C) edge [loop below] node[below] {$b$} (C);
    \path[->] (C) edge [loop above] node[above] {$a$} (C);
  \end{tikzpicture}
  \begin{legend}
    The graphical layout of this automaton was described by hand,
    using the \tikzname package.\index{A1@$\Ac_1$}
  \end{legend}
  \caption{The automaton $\Ac_1$}
  \label{fig:a1}
\end{figure}

Let's consider the Boolean automaton $\Ac_1$ (\autoref{fig:a1}), part
of the standard library.  It can be dumped using
\Index{\taffn{identity}}:

\begin{shell}
$ \kbd{vcsn-char-b identity-nodep a1.xml}
\end{shell}

Usual shell indirections (\samp{|}, \samp{>}, and \samp{<}) can be
used to combine \tafkit commands.  For instance, this is an easy means
to bring a local copy of this file:

\begin{shell}
$ \kbd{vcsn-char-b identity-nodep a1.xml >my-a1.xml}
\end{shell}

\tafkit uses XML to exchange automata, to get graphical rendering of
the automaton, you may either invoke \Index{\taffn{-o dot identity}} and then
use a Dot compliant program, or use \Index{\taffn{display}} that does
both.

\begin{shell}
$ \kbd{vcsn-char-b --output-type=dot identity-nodep a1.xml >a1.dot}
\end{shell}


\subsubsection{Determinization of $\Ac_1$}
To determinize a Boolean automaton, call the
\Index{\taffn{determinize}} function:

\begin{shell}
$ \kbd{vcsn-char-b identity-nodep a1.xml | vcsn-char-b determinize - >a1det.xml}
\end{shell}

To get information about an automaton, call the \Index{\taffn{info}} function:
\begin{shell}
$ \kbd{vcsn-char-b info a1det.xml}
\end{shell}

Or use dotty to visualize it:
\begin{shell}
$ \kbd{vcsn-char-b --output-type=dot identity a1det.xml >a1det.dot}
\end{shell}

\subsubsection{Evaluation}

To \index{\taffn{eval}}evaluate whether a word is accepted:

\begin{shell}
$ \kbd{vcsn-char-b eval-nodep a1.xml 'abab'}
\end{shell}
\begin{shell}
$ \kbd{vcsn-char-b eval-nodep a1.xml 'bbba'}
\end{shell}

\noindent
where 1 (resp. 0) means that the word is accepted (resp. not accepted)
by the automaton.

\subsection{Interactive Definition of Automata}

\tafkit provides a text interface to define automata interactively,
rather than having to deal with XML files.  Two functions are
available:
\begin{description}
\item[\taffn{define-automaton}] to build a fresh automaton from scratch,
\item[\taffn{edit-automaton}] to modify an existing automaton,
\end{description}

The interface is based on a menu of choices:
\begin{shell}
$ \kbd{vcsn-char-b --alphabet=ab define-automaton all.xml}
Automaton description:
  States: (none)
  Initial states: (none)
  Final states: (none)

  Transitions: (none)

Please choose your action:
  1. Add states.
  2. Delete a state.

  3. Add a transition.
  4. Delete a transition.

  5. Set a state to be initial.
  6. Set a state not to be initial.

  7. Set a state to be final.
  8. Set a state not to be final.

  9. Display the automaton in Dotty.

  10. Exit.

Your choice [1-10]:
\end{shell}

\noindent
If you enter \kbd{1}, you will then be prompted for the number of
states to add, say \kbd{1} again.  The state \code{0} was created.  To
make it initial select \kbd{5}, and:

\begin{shell}
Your choice [1-10]: \kbd{5}
  For state: \kbd{0}
\end{shell}

Likewise to make it final, using choice \kbd{7}.  Finally, let's add a
transition:

\begin{shell}
Your choice [1-10]: \kbd{3}
  Add a transition from state: \kbd{0}
  To state: \kbd{0}
  Labeled by the expression: \kbd{a+b}
\end{shell}

\noindent
The automaton is generalized, that is to say, rational expressions are
valid labels.

On top of the interactive menu, the current definition of the
automaton is reported in a textual yet readable form:

\begin{shell}
Automaton description:
  States: 0
  Initial states: 0
  Final states: 0

  Transitions:
    1: From 0 to 0 labeled by (\withweighttt{1}{a})+(\withweighttt{1}{b})
\end{shell}

\noindent
Interestingly enough, states are numbered from 0, but transitions
numbers start at 1.  Also, not that weights are reported, although
only \code{1} is valid for Boolean automata.

Finally, hit \kbd{10} to save the resulting automaton in the file
\file{all.xml}.

\subsection{Rational expressions and Boolean automata}

\Vauc provides functions to manipulate rational expressions associated
to Boolean automata.  This provides an alternative means to create
automata:

\begin{shell}
$ \kbd{vcsn-char-b --alphabet=ab exp-to-aut '(a+b)*' >all.xml}
\end{shell}
\begin{shell}
$ \kbd{vcsn-char-b --output-type=dot identity all.xml >all.dot}
\end{shell}

\subsection{Token representations}

When dealing with rational expressions in \tafkit, one may be willing to,
for example, change the representation of the epsilon. More generally,
the rational expressions parser understand $10$ such tokens. They are:

\begin{itemize}
\item \verb-OPAR-: the opening association parenthesis.
\item \verb-CPAR-: the closing association parenthesis.
\item \verb-PLUS-: the semi-ring additive law.
\item \verb-TIMES-: the monoid concatenation law.
\item \verb-STAR-: the Kleene star.
\item \verb-ONE-: the identity of the monoid.
\item \verb-ZERO-: the zero of the semi-ring.
\item \verb-OWEIGHT-: the opening weight brace.
\item \verb-CWEIGHT-: the closing weight brace.
\item \verb-SPACE-: a whitespace character.
\end{itemize}

\noindent
Each token must be a non-empty string, with arbitrary length. Some checks
will be done by \tafkit, to ensure tokens do not collide. You can also
use the \verb-ALPHABET- token an arbitrary number of times, to append letters
to the current alphabet. The following commands:

%% FIXME: include ({1} a) in the example
\begin{shell}
$ \kbd{vcsn-char-b --alphabet=ab exp-to-aut '((a) + b)*' >parser.xml}
\end{shell}
\begin{shell}
$ \kbd{vcsn-char-b --output-type=dot identity parser.xml >parser.dot}
\end{shell}

\noindent
, will give the same results as:
%% FIXME: include ({1} a) in the example
\begin{shell}
$ \kbd{vcsn-char-b --alphabet=a --parser="ALPHABET=b ONE=e STAR=star" exp-to-aut '(a + b)star' >parser2.xml}
\end{shell}
\begin{shell}
$ \kbd{vcsn-char-b --output-type=dot identity parser2.xml >parser2.dot}
\end{shell}

\noindent
With the \verb-ALPHABET- token, you can specify two types of letters:

\begin{itemize}
\item letters: one character is used to represent a letter.
\item words: many characters are used to represent a letter.
\end{itemize}

For example, \verb-ALPHABET=letters:abc- defines the alphabet with three letters
$\{\verb-a-, \verb-b-, \verb-c-\}$, while \verb-ALPHABET=words:abc- defines the
alphabet with only one letter $\{\verb-abc-\}$. Letters are separated by commas, and
each \tafkit context defaults to either letters (vcsn-char-b eg) or words
(vcsn-int-b eg). \verb|vcsn-int-b --alphabet=0,1,2,3,4,5,6,7,8,9| and
\verb|vcsn-int-b --alphabet=letters:0123456789'| will give the same alphabets.

Everywhere you want to use special characters used by the \verb|--parser|
option, prepending a backslash character will escape it. So, you can write:
\verb|ALPHABET=\,,\=| which defines the alphabet with the two letters \verb-,-
and \verb-=-.

Finally whenever you may put a single character you may write a pair a words.
The following construction is then valid: \verb|ALPHABET=(\,,\))|, and defines
the alphabet with only one letter: the pair whose first component is \verb-,-
and the second one is \verb-)-.

For more details, the grammar of the \verb|--parser| option is included in the
source code in EBNF notations.

\subsubsection{Minimizing}

This automaton, constructed following the Thompson algorithm, is not
the simplest one: it can be \index{minimize@\taffn{minimize}}minimized:

\begin{shell}
$ \kbd{vcsn-char-b minimize all.xml >allmin.xml}
\end{shell}
\begin{shell}
$ \kbd{vcsn-char-b --output-type=dot identity allmin.xml >allmin.dot}
\end{shell}

\bigskip

Computing the language recognized by a Boolean automaton can be done
using \Index{\taffn{aut-to-exp}}:

\begin{shell}
$ \kbd{vcsn-char-b aut-to-exp all.xml}
\end{shell}
\begin{shell}
$ \kbd{vcsn-char-b aut-to-exp allmin.xml}
\end{shell}

\Vauc provides several algorithms that build an automaton that
recognizes a given language.  The following sequence computes the
minimal automaton of \samp{(a+b)*ab(a+b)*}.

\begin{shell}
$ \kbd{vcsn-char-b --alphabet=ab standard "(a+b)*a.b.(a+b)*" | vcsn-char-b quotient - >l1.xml}
\end{shell}
\begin{shell}
$ \kbd{vcsn-char-b --output-type=dot identity l1.xml >l1.dot}
\end{shell}

\subsection{Available functions}

The whole list of supported commands is available via
\option{--list-commands}:

\begin{shell}
$ \kbd{vcsn-char-b --list-commands}
\end{shell}


%% Une definition plus rigoureuse des algorithmes devrait etre fournie
%% en annexe.
%% This section gives a brief definition of all functions that \Vauc
%% provides for manipulating Boolean automata.  All these algorithms are
%% invoked using \samp{vcsn-char-b \var{algorithm-name} [\var{arguments}]}. If
%% the argument is replaced by \samp{-} then the program will read an
%% argument from the standard input.  All algorithms dump their result to
%% the standard output, except the ``tests'' functions that also return
%% an exit status (0 if the test is successful, anything else otherwise).
%%
%% In the following:
%% \begin{itemize}
%% \item \var{a1} and \var{a2} are two Boolean automata described
%%   in \Vauc XML format;
%% \item \var{w} is a word, for example \samp{"aabb"} if you are
%%   working on an alphabet that contains the letters \samp{a} and
%%   \samp{b};
%% \item \var{exp} is a rational expression denoting a language;
%% \item \var{n} is a non-negative integer.
%% \end{itemize}
%%
%%
%% \begin{fnsection}{Input/output work with automata}
%% \item{define-automaton}{}{Define an automaton from scratch.}
%% \item{edit-automaton}{a1}{Edit an existing automaton.}
%% \item{info}{a1}{Print the number of states, transitions, initial and
%%     final states of \var{a1}.}
%% \item{display}{a1}{Display the automaton using Dotty.}
%% \item{dump}{a1}{Dump the automaton to Dot format.}  \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Tests and evaluation on automata}
%% \item{are-isomorphic}{a1 a2}{Test whether \var{a1} and \var{a2} are
%%     isomorphic.}
%% \item{evaluation}{a1 w}{Test whether the word \var{w} is accepted by
%%     \var{a1}.}
%% \item{is-deterministic}{a1}{Test whether \var{a1} is deterministic.}
%% \item{is-empty}{a1}{Test whether \var{a1} accepts no word.}  \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Generic algorithms for automata}
%% \item{accessible}{a1}{Extract the sub-automaton of accessible states
%%     of \var{a1}.}
%% \item{co-accessible}{a1}{Extract the sub-automaton of co-accessible
%%     states of \var{a1}.}
%% \item{trim}{a1}{Trim the automaton \var{a1}.}
%% \item{transpose}{a1}{Compute the automaton accepting the mirror
%%     language of the one accepted by \var{a1}.}
%%
%% \item{closure}{[-bf] a1}{$\varepsilon$-removal algorithm.}
%%   & \option{-b} : backward closure\\
%%   & \option{-f} : forward closure\\
%% \item{concatenate}{a1 a2}{Concatenate \var{a1} to \var{a2}.}
%% \item{sum}{aut1 aut2}{Compute the sum of \var{a1} and \var{a2}.}
%% %\item{normalize}{aut1}{Compute an automaton with unique initial and
%% %    final states, with $\varepsilon$-transitions.}
%% %\item{standardize}{aut1}{Compute an automaton with unique initial
%% %    state without adding $\varepsilon$-transitions.}  \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Generic algorithms for automata on letters}
%% \item{rational-weight}{[-bf] a1}{$\varepsilon$-removal algorithm and make
%%     every transition labeled by a letter.}
%%   & \option{-b} : backward closure\\
%%   & \option{-f} : forward closure\\
%% \item{product}{a1 a2}{Compute the (Cartesian) product of \var{a1} and
%%     \var{a2}.}
%% \item{power}{a1 n}{Compute the (Cartesian) product of \var{a1} by
%%     itself \var{n} times.}
%% \item{quotient}{a1}{Compute the minimal automaton in bi-simulation
%%     with \var{a1}.}  \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Algorithms specific to Boolean automata}
%% \item{determinize}{a1}{Compute the determinized automaton of
%%     \var{a1}.}
%% \item{complement}{a1}{Compute an automaton that accepts the complement
%%     language of the one accepted by \var{a1}.}
%% \item{minimize}{[-hm] a1}{Minimize the {\em deterministic} automaton
%%     \var{a1}.}
%%   & \option{-h} : use the Hopcroft algorithm\\
%%   & \option{-m} : use the Moore algorithm\\
%%   \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Conversion between automata and expressions}
%% \item{aut-to-exp}{a1}{Print a rational expression denoting the
%%     language accepted by \var{a1}.}
%% \item{expand}{exp}{Partially expand rational expressions. For
%%     instance, expanding \samp{a(b+ab(a+b))} will produce
%%     \samp{aab.(a+b)*+ab}}
%% \item{derived-term}{exp}{Compute the derived term automaton of
%%     \var{exp}.}
%% \item{standard}{exp}{Compute the standard (Glushkov) automaton of
%%     \var{exp}.}
%% \item{thompson-of}{exp}{Compute the Thompson automaton of \var{exp}.}
%%   \hline
%% \end{fnsection}
%%

\newpage
\section{Transducers}
\label{sec:vcsn-char-fmp-b}

While the \Vauc library supports two views of transducers, currently
\tafkit only provides one view:

\begin{description}
\item[vcsn-char-fmp-b] considering a transducer as a weighted automaton of a
  product of free monoid,
\end{description}

In a forthcoming release, \tafkit will provide:

\begin{description}
\item[vcsn-char-rw] considering a transducer as a machine that takes a
  word as input and produce another word as (two-tape automata).
\end{description}

Both views are equivalent and \Vauc provides algorithms to pass from a
view to the other one.

\subsection{Example}

\begin{figure}[tp]
  \begin{center}
    \begin{tikzpicture}[automaton]
      % states
      \node[state, initial left, accepting below] (A) at (0,0) {};
      \node[state] (B) at (3,0) {};
      \node[state] (C) at (6,0) {};
      % transitions
      \path[->] (A) edge [loop above] node[above] {$\IOL{0}{0}$} (A);
      \path[->] (C) edge [loop above] node[above] {$\IOL{1}{1}$} (C);
      \path[->] (A) edge [bend left] node[above] {$\IOL{1}{0}$} (B);
      \path[->] (B) edge [bend left] node[above] {$\IOL{1}{1}$} (A);
      \path[->] (B) edge [bend left] node[above] {$\IOL{0}{0}$} (C);
      \path[->] (C) edge [bend left] node[above] {$\IOL{0}{1}$} (B);
    \end{tikzpicture}
    \begin{legend}
      The transducer computing the quotient by 3 of a binary number.
    \end{legend}
    \caption{Rational-weight transducer $\Tc_1$}
    \label{fig:t1}
  \end{center}
\end{figure}

%% \begin{figure}[tp]
%%   \begin{center}
%
%%\begin{tikzpicture}[automaton]
%%  % states
%%  \node[state, initial left] (A) at (0,0) {};
%%  \node[state, accepting right] (B) at (3,0) {};
%%  \FinalL{s}{A}{(,1)}
%%  % transitions
%%  \path[->] (A) edge [loop above] node[above] {$(1,0)$} (A);
%%  \path[->] (B) edge [loop above] node[above] {$(1,1)$} (B);
%%  \path[->] (B) edge [loop below] node[below] {$(0,0)$} (B);
%%  \path[->] (A) edge node[above] {$(0,1)$} (B);
%%  \end{tikzpicture}
%%}
%%     \caption{Transducer $\Tc_2$ adding 1 to a binary number}
%%     \label{fig:t2}
%%   \end{center}
%% \end{figure}

To experiment with transducers, we will use \index{T1@$\Tc_1$}$\Tc_1$,
described in \autoref{fig:t1}, and part of the automaton library
(\autoref{char-fmp-b:t1}).

%% \subsubsection{Evaluation}
%%
%% Currently \tafkit requires the user to specify the alphabets to use
%% using \option{--alphabet1} and \option{--alphabet2}.
%%
%% \begin{shell}
%% $ \kbd{vcsn-char-fmp-b --alphabet1=ab eval t1.xml 'bba'}
%% \end{shell}

\subsubsection{Domain}
The transducer $T$ only accepts binary numbers divisible by 3.

\begin{shell}
$ \kbd{vcsn-char-fmp-b identity-nodep t1.xml | vcsn-char-fmp-b --alphabet1=ab domain - >div-by-3.xml}
\end{shell}

Now the file \file{divisible-by-3.xml} contains the description of a
Boolean automaton that accepts only the numbers divisible by 3:

\begin{shell}
$ \kbd{vcsn-char-b --output-type=dot identity div-by-3.xml >div-by-3.dot}
\end{shell}


%% \subsubsection{to-tdc}
%% Each transducer can be transformed to the other type of transducer
%% thanks to the \taffn{to-tdc} and \taffn{to-rw-tdc} functions.
%% \begin{shell}
%% $ \kbd{vcsn-char-rw to-tdc quot_3_rw.xml > quot_3.xml}
%% $ \kbd{vcsn-char-fmp-b to-rw-tdc add1.xml > add1_rw.xml}
%% \end{shell}
%%
%% \subsubsection{Composing}
%% \begin{shell}
%% $ \kbd{vcsn-char-fmp-b compose quot_3.xml add1.xml}
%% \end{shell}

\subsection{Available functions}
The following functions are available for both \command{vcsn-char-rw}
and \command{vcsn-char-fmp-b} programs.  To invoke them, run
\samp{\var{program} \var{algorithm-name} [\var{arguments}]}.

\begin{shell}
$ \kbd{vcsn-char-fmp-b --list-commands}
\end{shell}

%% In the following:
%%
%% \begin{itemize}
%% \item \var{t1} and \var{t2} are two transducers (either ``rational-weight''
%%   or not) described in \Vauc XML format;
%% \item \var{w} is a word, for example \samp{"aabb"} if you are working
%%   on an alphabet that contains the letters \samp{a} and \samp{b};
%% \item \var{a} is a Boolean automaton;
%% \item \var{t1-rw} is a rational-weight transducer;
%% \item \var{t1-fmp} is a transducer (seen as an automaton over a free
%%   monoid product).
%% \end{itemize}
%%
%% \begin{fnsection}{Input/output work with transducers}
%% \item{define-automaton}{}{Define a transducer from scratch.}
%% \item{edit-automaton}{t1}{Edit an existing transducer.}
%% \item{info}{t1}{Print the number of states, transitions, initial and
%%     final states of \var{t1}.}
%% \item{display}{t1}{Display the transducer using DOTTY.}  \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Tests and evaluation on transducers}
%% \item{are-isomorphic}{t1 t2}{Test if the two transducers are
%%     isomorphic.}
%% \item{evaluation}{t1 w}{Compute the evaluation of \var{w} by
%%     \var{t1}.}
%% \item{is-empty}{t1}{Test if \var{t1} realizes the empty relation.}
%%   \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Generic algorithm for transducers}
%% \item{closure}{t1}{$\varepsilon$-removal algorithm.}
%%
%% \item{compose}{t1 t2}{Compute a transducer realizing $f_2 \circ f_1$,
%%     where $f_1$ (resp. $f_2$) is the function associated to \var{t1}
%%     (resp. \var{t2}).}
%%
%% \item{domain}{t1}{Compute an automaton accepting all input accepted by
%%     the transducer t1.}
%%
%% \item{evaluation}{t1}{Compute the evaluation of w by t1.}
%%
%% \item{evaluation-aut}{t1}{Compute a Boolean automaton describing the
%%     words produced by the language described by a evaluated by t1.}
%%
%% \item{image}{t1}{Compute an automaton describing all output produced
%%     by the transducer t1.}
%%
%% %\item{transpose}{t1}{Compute the transposed of the transducer t1.}
%%
%% \item{trim}{t1}{Compute the trimmed transducer of t1.}  \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Algorithms for transducers}
%% \item{sub-normalize}{t1-fmp}{Compute the sub-normalized transducer of
%%     \var{t1-fmp}.}
%% \item{is-sub-normalized}{t1-fmp}{Test if \var{t1-fmp} is
%%     sub-normalized.}
%% \item{composition-cover}{t1-fmp}{.}%%FIXME
%% \item{composition-co-cover}{t1-fmp}{.}%%FIXME
%% \item{b-compose}{t1-fmp t2-fmp}{Compose \var{t1-fmp} and
%%     \var{t2-fmp}, two unweighted normalized or sub-normalized
%%     transducers.}
%% \item{to-rw-tdc}{t1-fmp}{Compute the equivalent realtime transducer
%%     of \var{t1-fmp}.}
%% \item{intersection}{a}{Transform \var{a} in a fmp transducer by
%%     creating, for each word, a pair containing twice this word.}
%%   \hline
%% \end{fnsection}
%%
%%
%% \begin{fnsection}{Algorithms for ``realtime'' transducers}
%% \item{realtime}{t1-rw}{Compute the realtime transducer of  \var{t1-rw}.}
%% \item{is-realtime}{t1-rw}{Test if \var{t1-rw} is realtime.}
%% \item{to-tdc}{t1-rw}{Compute the equivalent fmp transducer of \var{t1-rw}.}
%% \hline
%% \end{fnsection}

\newpage
\section{\Z-Automata}
\label{sec:vcsn-char-z}

This part shows the use of the program \Index{\command{vcsn-char-z}}, but
all comments should also stand for the programs
\command{vcsn-char-z-min-plus} and \command{vcsn-char-z-max-plus}.

Again, we will toy with some of the automata provided by
\command{vcsn-char-z}, see \autoref{sec:auto:char-z}.

\subsection{Counting \samp{b}s}

\begin{figure}[tp] \centering
  \begin{tikzpicture}[automaton]
    % states
    \node[state, initial] (A) at (0,0) {};
    \node[state, accepting] (B) at (3,0) {};
    % initial--final
    % transitions
    \path[->] (A) edge node[above] {$b$} (B);
    \path[->] (A) edge [loop below] node[below] {$b$} (A);
    \path[->] (A) edge [loop above] node[above] {$a$} (A);
    \path[->] (B) edge [loop below] node[below] {$b$} (B);
    \path[->] (B) edge [loop above] node[above] {$a$} (B);
  \end{tikzpicture}
  \begin{legend}
    Considered without weight, $\Bc_1$ accepts words with a \samp{b}.
    With weights, it counts the number of \samp{b}s.
    \index{B1@$\Bc_1$}
  \end{legend}
  \caption{The automaton $\Bc_1$}
  \label{fig:b1}
\end{figure}

Let's consider $\Bc_1$ (\autoref{fig:b1}), an
\index{N-automaton@$\mathbb{N}$-automaton}$\mathbb{N}$-automaton,
\textit{i.e.}  an automaton whose label's weights are in $\mathbb{N}$.
This time the evaluation of the word \var{w} by the automaton
$\Bc_1$ will produce a number, rather than simply accept or
reject \var{w}.  For instance let's evaluate \samp{abab} and
\samp{bbab}:

\begin{shell}
$ \kbd{vcsn-char-z identity-nodep b1.xml | vcsn-char-z eval - 'abbb'}
\end{shell}
\begin{shell}
$ \kbd{vcsn-char-z identity-nodep b1.xml | vcsn-char-z eval - 'abab'}
\end{shell}

\noindent
Indeed, $\Bc_1$ counts the number of \samp{b}s.

\subsubsection{Power}

Now let's consider the $\Bc_1^n$, where
\begin{displaymath}
  \Bc_1^n = \prod_{i=1}^n \Bc_1, n > 0
\end{displaymath}

\noindent
This is implemented by the \Index{\taffn{power}} function:

\begin{shell}
$ \kbd{vcsn-char-z identity-nodep b1.xml | vcsn-char-z power - 4 >b4.xml}
\end{shell}
\begin{shell}
$ \kbd{vcsn-char-z power b1.xml 4 > b4.xml}
\end{shell}

\noindent
The file \file{b4.xml} now contains the automaton $\Bc_1^4$.  Let's
check that the evaluation of the words \samp{abab} and \samp{bbab} by
$\Bc_1^4$ gives the fourth power of their evaluation by $\Bc_1$:

\begin{shell}
$ \kbd{vcsn-char-z eval b4.xml 'abbb'}
\end{shell}
\begin{shell}
$ \kbd{vcsn-char-z eval b4.xml 'abab'}
\end{shell}

\subsubsection{Quotient}

Successive products of an automaton create a lot of new states and
transitions.

\begin{shell}
$ \kbd{vcsn-char-z identity-nodep b1.xml | vcsn-char-z info -}
\end{shell}
\begin{shell}
$ \kbd{vcsn-char-z info b4.xml}
\end{shell}

One way of reducing the size of our automaton is to use the
\Index{\taffn{quotient}} algorithm.

\begin{shell}
$ \kbd{vcsn-char-z quotient b4.xml | vcsn-char-z info -}
\end{shell}


\subsection{Available functions}

In this section you will find a brief definition of all functions for
manipulating weighted automata. The following functions are available
for both.  They are called using \command{vcsn-char-z},
\command{vcsn-char-z-max-plus}, and \command{vcsn-char-z-min-plus} run as
\samp{\var{program} \var{algorithm-name} [\var{arguments}]}.

\begin{shell}
$ \kbd{vcsn-char-z --list-commands}
\end{shell}

%% \smallskip
%%
%% In the following:
%%
%% \begin{itemize}
%% \item \var{a1} and \var{a2} are two weighted automata described in
%%   \Vauc XML format;
%% \item \var{w} is a word, for example \samp{aabb} if you are working on
%%   an alphabet that contains the letters \samp{a} and \samp{b};
%% \item \var{exp} is a rational expression denoting a language;
%% \item \var{n} is a non-negative integer.
%% \end{itemize}
%%
%%
%% \begin{fnsection}{Input/output work with weighted automata}
%% \item{define-automaton}{}{Define an automaton from scratch.}
%% \item{edit-automaton}{a1}{Edit an existing automaton.}
%% \item{info}{a1}{Print the number of states, transitions, initial and
%%     final states of \var{a1}.}
%% \item{display}{a1}{Display the automaton using DOTTY.}  \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Tests and evaluation on weighted automata}
%% \item{are-isomorphic}{a1 a2}{Test if the two automata are isomorphic.}
%% \item{evaluation}{a1 w}{Compute the evaluation of \var{w} by
%%     \var{a1}.}
%% \item{is-empty}{a1}{.}  \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Generic algorithms for automata}
%% \item{accessible}{a1}{Extract the sub-automaton of accessible states
%%     of \var{a1}.}
%% \item{co-accessible}{a1}{Extract the sub-automaton of co-accessible
%%     states of \var{a1}.}
%% \item{trim}{a1}{Trim the automaton \var{a1}.}
%% \item{transpose}{a1}{Compute the automaton accepting the mirror
%%     language of the one accepted by \var{a1}.}
%% \item{closure}{[-bf] a1}{$\varepsilon$-removal algorithm.}
%%   & \option{-b} : backward closure\\
%%   & \option{-f} : forward closure\\
%% \item{concatenate}{a1 a2}{Concatenate \var{a1} to \var{a2}.}
%% \item{sum}{a1 a2}{Compute the sum of \var{a1} and \var{a2}.}
%% %\item{normalize}{a1}{Compute an automaton with unique initial and
%% %    final states, with $\varepsilon$-transitions.}
%% %\item{standardize}{a1}{Compute an automaton with unique initial state
%% %    without adding $\varepsilon$-transitions.}  \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Generic algorithms for automata on letters}
%% \item{realtime}{[-bf] a1}{$\varepsilon$-removal algorithm and make
%%     every transition labeled by a letter.}
%%   & \option{-b} : backward closure\\
%%   & \option{-f} : forward closure\\
%% \item{product}{a1 a2}{Compute the (Cartesian) product of \var{a1} and
%%     \var{a1}.}
%% \item{power}{a1 n}{Compute the (Cartesian) product of \var{a1} by
%%     itself \var{n} times.}
%% \item{quotient}{a1}{Compute the $\mathbb{Z}$-quotient of \var{a1}.}
%%   \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Conversion between automata and expressions}
%% \item{aut-to-exp}{a1}{.}%%FIXME
%% \item{expand}{exp}{Partially expand rational expressions.}
%% \item{derived-term}{exp}{Compute the derived term automaton of
%%     \var{exp}.}
%% \item{standard}{exp}{Compute the standard (Glushkov) automaton of
%%     \var{exp}.}
%% \item{thompson-of}{exp}{Compute the Thompson automaton of \var{exp}.}
%%   \hline
%% \end{fnsection}


% \section{Building your own automaton}
%%FIXME: Here we should give the usage of define_automaton function.

\appendix

\chapter{Automaton Repository}

\Vauc comes with a set of interesting automata that can be used to toy
with \tafkit (\autoref{sec:tafkit}) for instance.  In the chapter, we
present each one of these automata.

\end{document}


%%% Local Variables:
%%% mode: latex
%%% ispell-local-dictionary: "american"
%%% End:

% LocalWords:  priori semiring monoids tafkit
% LocalWords:  svn vaucanson cd sudo
% LocalWords:  determinize vcsn semiring rw tdc TAF aut dmi determinizes bz xml
% LocalWords:  det detmin eval abab bbba aabb determinized Hopcroft aab fmp dom
% LocalWords:  Glushkov thompson realtime bbab abbb monoids zmin zmax
% LocalWords:  semiring ite Glushkov Rouen Kleene Schutzenberger mutatis
% LocalWords:  mutandis Kleene's Hadamard
