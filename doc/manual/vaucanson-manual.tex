\documentclass[a4paper]{report}

\usepackage[american]{babel}
\usepackage[latin1]{inputenc}
\usepackage{a4wide}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{hyperref}
\usepackage{textcomp}
\usepackage{tabularx}
\usepackage{url}
\usepackage{graphicx}
\usepackage{xspace}

%% -------------------- %%
%% Tikz configuration.  %%
%% -------------------- %%

\usepackage{pgf,tikz}
\usetikzlibrary{automata}
\usetikzlibrary{arrows}
\tikzstyle{automaton}=[shorten >=1pt,
                       node distance=2cm,
                       pos=.4,
                       >=stealth',
                       every state/.style={draw,very thick,minimum size=7mm},
                       every edge/.style={draw,thick},
                       initial distance=7mm,
                       accepting distance=7mm,
                       initial text=]
\tikzstyle{loop right}=[right,out=25,in=-25,loop,pos=.5]
\tikzstyle{loop above}=[above,out=115,in=65,loop,pos=.5]
\tikzstyle{loop left}=[left,out=205,in=155,loop,pos=.5]
\tikzstyle{loop below}=[below,out=295,in=245,loop,pos=.5]
\tikzstyle{accepting}=[accepting by arrow]
\tikzoption{initial angle}{\tikzaddafternodepathoption{\def\tikz@initial@angle{#1}}}
\tikzoption{accepting angle}{\tikzaddafternodepathoption{\def\tikz@accepting@angle{#1}}}

%% ---------------------- %%
%% Mathematical symbols.  %%
%% ---------------------- %%
\renewcommand{\max}{\textrm{max}}
\renewcommand{\min}{\textrm{min}}
\newcommand{\Z}{\texorpdfstring{\ensuremath{\mathbb{Z}}}{Z}}
\newcommand{\R}{\texorpdfstring{\ensuremath{\mathbb{R}}}{R}}
\newcommand{\B}{\texorpdfstring{\ensuremath{\mathbb{B}}}{B}}
\newcommand{\Ae}{\ensuremath{A^{*}}}
\newcommand{\SerSAnMon}[2]%
    {\ensuremath{#1 \langle \! \langle  #2  \rangle \! \rangle}}

\newcommand{\newcal}[1]{%
  \expandafter \newcommand \csname #1c\endcsname%
  {\texorpdfstring{\ensuremath{\mathcal{#1}}}{#1}}%
}
\newcal{A}
\newcal{B}
\newcal{C}
\newcal{T}

\newtheorem{theorem}             {Theorem}[chapter]
\newtheorem{definition} [theorem]{Definition}
\newtheorem{remark}     [theorem]{remark}

\makeatletter
\newcommand{\Cxx}{%
  \valign{\vfil\hbox{##}\vfil\cr
    {C\kern-.1em}\cr
    $\hbox{\fontsize\sf@size\z@\textbf{+\kern-0.05em+}}$\cr}%
    \xspace
}
\makeatother

\newcommand{\bslash}{\texttt{\symbol{92}}}

%% FIXME: it should be (#1,#2) for FMP transducers
% A transition for a transducer.
\newcommand{\IOL}[2]{#1\!\mid\! #2}

%% ------- %%
%% Index.  %%
%% ------- %%

% The same argument is output and put in the index.
\usepackage{makeidx}
\makeindex
\newcommand{\Index}[1]{\index{#1}#1}

\usepackage{listings}
\lstset{%
  numbers=left,
  numberstyle=\tiny,
  stepnumber=5,
  numbersep=5pt,
  firstnumber=1,
  basicstyle=\small,
  frame=single,
  language=C++,
  float}

% Document a figure.
\newenvironment{legend}{%
  \begin{quote}%
    }{%
  \end{quote}%
}

%% Display an interactive session.
\usepackage{alltt}
\newenvironment{shell}
{\begin{alltt}}
{\end{alltt}}

% @VcsnVersion@
\def\VcsnVersion{1.2.95a}

%% ----------------------- %%
%% Texinfo like commands.  %%
%% ----------------------- %%

\newcommand\kbd[1]{\textsl{\texttt{#1}}}
\newcommand\file[1]{`\texttt{#1}'}
\newcommand\command[1]{\texttt{#1}}
\newcommand\var[1]{{\ttfamily\itshape #1}}
\newcommand\code[1]{\texttt{#1}}
\newcommand\samp[1]{`\texttt{#1}'}
\newcommand\option[1]{`\texttt{#1}'}

%% -------------------- %%
%% Vaucanson commands.  %%
%% -------------------- %%

%% A TAF-kit function name (i.e., the first argument for TAF-Kit
%% programs).
\newcommand{\taffn}[1]{\code{#1}}
\newcommand{\tafkit}{\textsc{TAF-Kit}\xspace}
\newcommand{\Vauc}{\textsc{Vaucanson}\xspace}
%% Attach weights in a type writer environment.
\newcommand{\withweighttt}[2]{\symbol{`\{}#1\symbol{`\}} #2}

% \begin{fnsection}{NAME}
% -----------------------
% A group of taf-kit functions.
% Putting the ending hline in the end section is tempting, but fails.
\newenvironment{fnsection}[1]{%
  % \item{NAME}{ARGS}{DOC}
  % ----------------------
  % Define a taf-kit function.
  % We use \item because it has Emacs indentation support.
  \renewcommand{\item}[3]{\texttt{##1} \var{##2} & ##3\\}

  \tabularx{\textwidth}{|l|X|}%
    \hline\multicolumn{2}{|c|}{#1} \\\hline%
  }{%
  \endtabularx%
}

\def\manualtitle{\Vauc User's Manual}

%% ---------- %%
%% Document.  %%
%% ---------- %%
\begin{document}
\vspace*{50pt}
\vskip4pt \hrule height 4pt width \hsize \vskip4pt
\begin{center}
  \Huge \manualtitle
\end{center}
\vspace*{-1.5ex}
\vskip4pt \hrule height 4pt width \hsize \vskip4pt

\hfill compiled on \today, for version \VcsnVersion

\vfill

\setcounter{tocdepth}{2}
\makeatletter
\@starttoc{toc}
\makeatother

\vfill

\chapter*{Introduction}
\label{sec:intro}

\Vauc is a free software platform dedicated to the manipulation of
finite state automata.  Here, `finite state automata' is to be
understood in the broadest sense: \Vauc supports \emph{weighted}
automata over a free monoid, and even \emph{weighted} automata on some
\emph{non free monoids} (currently only products of free
monoids---a.k.a. transducers---are supported).

\bigskip

The platform consists in a couple of components:
\begin{description}
\item[The \Vauc library] is a \Cxx library that implements objects for
  automata, rational expressions, as well as algorithms on these
  objects.  This library is generic, in the sense that it makes it
  possible to write an algorithm once and apply it to different types
  of automata.  However this genericity is achieved in a way that
  should not cause any slowdown at runtime: because the type of the
  automata manipulated is known at compile time, compiling an
  algorithm will generate code that is almost as efficient as an
  algorithm dedicated to this type of automaton.

\item[\tafkit] is a command-line interface to the library, that allows
  user to execute \Vauc's algorithms without any knowledge of \Cxx.
  Because the \Vauc library needs to know the type of automata at
  compile time, the \tafkit interface has been instantiated for a
  predefined set of common automaton types.

  \tafkit does not allow to write new algorithms nor to manipulate new
  types of automata, but it makes it possible to combine without
  efforts a large set of algorithms on common automata types.

\item[A repository of automata] that shows examples of automata of
  various types, and also contains tools to create families of
  automata.
\end{description}

Ideally this manual should document all of these components.
Presently it only documents \tafkit because that is the more
accessible part of \Vauc.


\chapter{Administrativia}

\section{Getting \Vauc}

The latest version of the \Vauc platform can be downloaded from
\url{http://vaucanson.lrde.epita.fr/}.

\section{Licensing}

Vaucanson is a free software released under the GNU General Public
Licence version 2. If you are unfamiliar with this license, please
read the file \file{COPYING} (at the root of the source tree) for
details.

\section{Building \Vauc}\label{sec:building}

Detailed information is provided in the files \file{INSTALL}, which is
generic to all packages using the GNU Build System, and
\file{doc/README.pdf} which details \Vauc's specific build process.
The typical installation commands will install \Vauc in
\file{/usr/local/}.

\begin{shell}
$ \kbd{cd vaucanson-\VcsnVersion}
$ \kbd{./configure}
$ \kbd{make}
$ \kbd{sudo make install}
\end{shell}

Although we discourage it, you may also use \Vauc without installing
it: you would have to use \kbd{-I
  /full-path-to/vaucanson-\VcsnVersion/include} when compiling C++
programs, and move to directory
\file{vaucanson-\VcsnVersion/taf-kit/tests/} to execute \tafkit.
(This directory contains wrapper around the real \tafkit programs from
\file{taf-kit/tests/} that enable them to run locally.)

\section{Getting in Touch}

Please send any question or comment to \url{vaucanson@lrde.epita.fr},
and report bugs to either our issue tracker at
\url{http://vaucanson.lrde.org/} or by mail to
\url{vaucanson-bugs@lrde.epita.fr}.

You can subscribe to these mailing lists at
\url{https://www.lrde.epita.fr/cgi-bin/mailman/listinfo/vaucanson} and
\url{https://www.lrde.epita.fr/cgi-bin/mailman/listinfo/vaucanson-bugs}
if you like, but this is not a requirement for sending mails.

\chapter{\tafkit}
\label{sec:tafkit}

\tafkit is a command-line interface to \Vauc.  It is a set of programs
that should be called from the shell and that can be used to chain
operations on automata.

\section{\tafkit Instances}

Because of the generic programming paradigm used in the \Vauc library,
the types of the automata manipulated have to be known at compile
time.  \tafkit has therefore been compiled for several predefined
types of automata.  It is actually the same program that is
\emph{instantiated} for different kinds of alphabets and weights.
Here are the names of these instances, and the kind of automata they
represent:

\begin{center}
\begin{tabular}{llll}
program name & automaton type & alphabet type & weight semiring \\
\hline
\command{vcsn-char-b} & automata &
  characters & $\langle\B,\lor,\land\rangle$ \\
\command{vcsn-int-b} & automata &
  integers & $\langle\B,\lor,\land\rangle$ \\
\command{vcsn-char-z} & automata &
  characters & $\langle\Z,+,\times\rangle$\\
\command{vcsn-char-zmax} & automata &
  characters & $\langle\Z,\max,+\rangle$\\
\command{vcsn-char-zmin} & automata &
  characters & $\langle\Z,\min,+\rangle$\\
\command{vcsn-char-r} & automata &
  characters & $\langle\R,+,\times\rangle$\\
\command{vcsn-char-char-b} & automata &
  pairs of characters & $\langle\B,\lor,\land\rangle$\\
\command{vcsn-char-int-b} & automata &
  pairs of character and integer & $\langle\B,\lor,\land\rangle$\\
\command{vcsn-int-int-b} & automata &
  pairs of integers & $\langle\B,\lor,\land\rangle$\\
\command{vcsn-char-fmp-b} & transducers &
  characters & $\langle\B,\lor,\land\rangle$\\
\command{vcsn-char-fmp-z} & transducers &
  integers & $\langle\Z,+,\times\rangle$\\
\command{vcsn-int-fmp-b} & transducers &
  characters & $\langle\B,\lor,\land\rangle$\\
\command{vcsn-int-fmp-z} & transducers &
  integers & $\langle\Z,+,\times\rangle$\\
\hline
\end{tabular}
\end{center}

\medskip

Many users of automata consider only automata whose transitions are
labeled by letters taken in an alphabet, which we call, roughly
speaking, \emph{classical} automata or \emph{Boolean}
automata. \command{vcsn-char-b} is the \tafkit instance they should
use.  A variant of this program, called \command{vcsn-int-b}, handles
Boolean automata whose letters are integers.  Other variants such as
\command{vcsn-char-char-b}, \command{vcsn-char-int-b}, or
\command{vcsn-int-int-b}, support alphabets of pairs.  All these are
called Boolean automata because each word is associated to a Boolean
\emph{weight}: either the word as accepted and its weight is
\emph{true}, or it is not and its weight is \emph{false}.

\Vauc actually supports automata with multiplicities, where words can
be associated to weights taken in any semiring.  For instance
\command{vcsn-char-z} associates each word to an integer.  The previous
table show other semirings that can be used as well.

\Vauc also supports weighted transducers.  These transducers are
actually automata over a product two free monoids.  In \Vauc we call
these FMP, for \emph{free monoïd products}.  The above table lists a
few \tafkit instance for FMP.

\section{A First Contact}\label{sec:firstcontact}

If you have fully installed \Vauc (see \autoref{sec:building}) you
should be able to just type any of the following commands and observe
their results.  If you only compiled \Vauc without installing it, you
should \command{cd} into the
\file{vaucanson-\VcsnVersion/taf-kit/tests/} directory and type
\kbd{./vcsn-char-b} instead of \kbd{vcsn-char-b} for each of the
following commands.

\begin{figure}[tbp] \centering
  \begin{tikzpicture}[automaton]
    % states
    \node[state, initial] (A) at (0,0) {};
    \node[state] (B) at (2,0) {};
    \node[state, accepting] (C) at (4,0) {};
    % initial--final
    % transitions
    \path[->] (A) edge node[above] {$a$} (B);
    \path[->] (B) edge node[above] {$b$} (C);
    \path[->] (A) edge [loop below] node[below] {$b$} (A);
    \path[->] (A) edge [loop above] node[above] {$a$} (A);
    \path[->] (C) edge [loop below] node[below] {$b$} (C);
    \path[->] (C) edge [loop above] node[above] {$a$} (C);
  \end{tikzpicture}
  \caption{The automaton $\Ac_1$, defined over the alphabet
    $\Sigma=\{a,b\}$.  It recognizes any word of $\Sigma^\star$ that
    contains $ab$. \label{fig:a1}}
\end{figure}

We are about to play with automaton $\Ac_1$ pictured
on~\autoref{fig:a1}.  \tafkit comes with a set of predefined automata,
and $\Ac_1$ happens to be one of those: it is called \file{a1.xml}.
This is a Boolean automaton whose alphabet consists in two characters
$\{a,b\}$ so will shall use the \command{vcsn-char-b} instance of
\tafkit.

The following command will just make sure that \tafkit knows about
this automaton.  It will display the number of states, transitions,
initial states, and final states of $\Ac_1$.

\begin{shell}
$ \kbd{vcsn-char-b info a1.xml}
States: 3
Transitions: 6
Initial states: 1
Final states: 1
\end{shell}%$

If you have the GraphViz package installed (see \file{doc/README.pdf}
for links) you can also display that automaton with:

\begin{shell}
$ \kbd{vcsn-char-b display a1.xml}
\end{shell}%$

\noindent
The displayed automaton won't have a layout as pretty as
\autoref{fig:a1}, but it represents the same automaton nonetheless.

$\Ac_1$ is a non-deterministic automaton.  We could determinize it
with the \command{determinize} command of \tafkit.  As most commands
of \tafkit, \command{determinize} produce its output (an XML file
representing the automaton) on the standard output, so we will want to
divert it to a file.

\begin{shell}
$ \kbd{vcsn-char-b determinize a1.xml > a1det.xml}
$ \kbd{vcsn-char-b info a1det.xml}
States: 4
Transitions: 8
Initial states: 1
Final states: 2
\end{shell}%$

\noindent
The determinized automaton has 4 states and 8 transitions.

Please note that \file{a1det.xml} is a file that we just created into
the current directory while \file{a1.xml} is a file that is predefined
in \Vauc's predefined automata repository.  We can call command
\command{info} on either files using the same syntax because \tafkit
will look for automata in both places.  The command \samp{vcsn-char-b
  list-automata} will list all predefined automata for this instance
of \tafkit.

In the pure Unix tradition, we can of course chain commands with
pipes.  For instance the above two commands could be rewritten

\begin{shell}
$ \kbd{vcsn-char-b determinize a1.xml | vcsn-char-b info -}
States: 4
Transitions: 8
Initial states: 1
Final states: 2
\end{shell}%$
\noindent
where \samp{-} stands for `\emph{read from standard input}'.


\tafkit actually supports a more efficient way of chaining commands,
called the \emph{internal pipe}.  It's called \emph{internal pipe}
because the pipe logic is taken care of by \tafkit himself, but
actually it is not using a Unix pipe at all: the commands are simply
serialized in the same process, using the automata object created by
the previous one.  It is more efficient because the automaton does not
have to be converted into XML for output, and then parsed as input of
the next command in the chain.  Here is how the \emph{internal pipe}
looks like; notice how the \samp{|} symbol is protected from its
evaluation by the shell.

\begin{shell}
$ \kbd{vcsn-char-b determinize a1.xml \bslash| info -}
States: 4
Transitions: 8
Initial states: 1
Final states: 2
\end{shell}%$
\noindent

\noindent In the above command, \samp{-} does not designate the
standard input, it denotes \emph{the result of the previous command}.

\section{\tafkit's Modus Operandi}\label{sec:modusoperandi}

All \tafkit instances work identically.  They just differ on the type
of automata they handle, and may offer different algorithms because
not all algorithms work on any automata type.

Any time \tafkit is run, it breaks its command line into command names
and arguments.

\[
  \underbrace{\text{\texttt{vcsn-char-b}}}_{\text{\tafkit instance}}~
  \underbrace{\underbrace{\text{\texttt{determinize}}}_{\text{name}}~
              \underbrace{\text{\texttt{a1.xml}}}_{\text{arg.}}}_{\text{command 1}}
  \text{\texttt{\bslash|}}
  \underbrace{\underbrace{\text{\texttt{info}}}_{\text{name}}
              \underbrace{\text{\texttt{-}}}_{\text{arg.}}}_{\text{command 2}}
\]

The \emph{internal pipe}, \samp{\bslash|}, is used to separate
commands.  A command start with a name, is can be followed by several
arguments (although only one is used in the above two commands).
These arguments can be very different depending on the command.  The
far we have used filenames as well as \samp{-} (to designate either
the standard input or the result of the previous command).  Some
commands will also accept plain text representing for instance a word
or a rational expression.

All commands will also accept some options.  There are options to
define what the alphabet is, options to define the types to use for
input and output, even options to fine-tune how some symbols will be
printed.  We shall get back to these options later.


For each command, \tafkit will
\begin{enumerate}
\item parse the options
\item parse all expected arguments
      (using indications that may have been given as options)
\item execute the algorithm
\item print the result (in a format that can be controlled using
  options)
\end{enumerate}

When commands are chained internally using \samp{\bslash|} and
\samp{-}, the parsing steps and printing steps are of course omitted.


\section{Writing Rational Expressions}

\subsection{Rational operators}

\Vauc supports the following operators for writing regular expressions.

\begin{center}
  \begin{tabular}{ll}
    \hline
    $e_1$$e_2$ & implicit concatenation \\
    $e_1$\code{.}$e_2$ & explicit concatenation \\
    $e_1$\code{+}$e_2$ & disjunction \\
    $e$\code{*} & Kleen star \\
    \code{(}$e$\code{)} & grouping \\
    \hline
  \end{tabular}
\end{center}

On the alphabet $\Sigma=\{a,b\}$, the language denoted by the rational
expression \samp{(a+b)*ab(a+b)*} contains all words that contain
\samp{ab}.

The \Vauc library always needs to know on which alphabet a rational
expression is defined in order to parse it.  This alphabet can be
indicated using option \option{--alphabet=ab} or the shorter form
\option{-aab} (see \autoref{sec:--alphabet} for more details).

For instance, here is how to create an automaton that recognizes the
same language as \samp{(a+b)*ab(a+b)*}, and make sure this automaton
is equivalent to the automaton $\Ac_1$ of \autoref{fig:a1}.

\begin{shell}
$ \kbd{vcsn-char-b exp-to-aut -aab "(a+b)*ab(a+b)*" > aut.xml}
$ \kbd{vcsn-char-b are-equivalent -v aut.xml a1.xml}
\end{shell}%$

\noindent The \option{-v} is used to request a plain English output
from \command{are-equivalent}.  Without it, \tafkit would just set its
status code.  (See \autoref{sec:verbose} for more details.)

\subsection{Empty word and null series}\label{sec:emptyword}

The default representation of the empty word (identity of the monoïd)
is \samp{1} when using characters or pair alphabets.  For instance let
us try the command \command{expand}, that distributes concatenations
over disjunctions:

\begin{shell}
$ \kbd{vcsn-char-b expand -aab '(a+1)(1+b)'}
a+ab+b+1
\end{shell}%$

Of course if we use \samp{1} as one character in the alphabet, the
same symbol cannot be used for representing the empty word.  \Vauc
actually choose the first available representation of the empty word
from the following list of candidate symbols: \samp{1}, \samp{e}, and
\samp{\_e}, \samp{eps}.

\begin{shell}
$ \kbd{vcsn-char-b expand -a01 '(0+e)(e+1)'}
0+01+1+e
$ \kbd{vcsn-char-b expand -a1e '(1+\_e)(\_e+e)'}
1+1e+e+_e
\end{shell}%$

For integer alphabets, the empty word is of course always \samp{e}.

Similarly the symbol used to represent the null series defaults to the
first representation from the following list that is compatible with
the alphabet: \samp{0}, \samp{z}, \samp{\_z}, \samp{zero}.

Section~\ref{sec:writingdata} shows how you can actually specify you
own representation for these symbols


\subsection{Weights}


\subsection{Interactive Definition of Automata}

The \tafkit command \taffn{edit-automaton} provides a textual
interface to define automata interactively.  The commands takes the
filename of the automata to define or modify in argument.  If the
files does not yet exist, you should specify the alphabet of your
automaton on the command line (using \option{--alphabet=} or
\option{-a} as will any other command), and the file will be created
when you exit the editor.  If the file does exist, the alphabet will
be read from the file along with the automaton itself, and the file
will be overwritten upon exit.

The interface is based on a menu of choices:
\begin{shell}
$ \kbd{vcsn-char-b edit-automaton --alphabet=ab test.xml}
Automaton description:
  States: (none)
  Initial states: (none)
  Final states: (none)

  Transitions: (none)

Please choose your action:
  1. Add states.
  2. Delete a state.

  3. Add a transition.
  4. Delete a transition.

  5. Set a state to be initial.
  6. Set a state not to be initial.

  7. Set a state to be final.
  8. Set a state not to be final.

  9. Display the automaton in Dotty.

  10. Exit.

Your choice [1-10]:
\end{shell}

\noindent
If you enter \kbd{1}, you will then be prompted for the number of
states to add, say \kbd{1} again.  The state \code{0} was created.  To
make it initial select \kbd{5}, and:

\begin{shell}
Your choice [1-10]: \kbd{5}
  For state: \kbd{0}
\end{shell}

Likewise to make it final, using choice \kbd{7}.  Finally, let's add a
transition:

\begin{shell}
Your choice [1-10]: \kbd{3}
  Add a transition from state: \kbd{0}
  To state: \kbd{0}
  Labeled by the expression: \kbd{a+b}
\end{shell}

\noindent
The automaton is generalized, that is to say, rational expressions are
valid labels.

On top of the interactive menu, the current definition of the
automaton is reported in a textual yet readable form:

\begin{shell}
Automaton description:
  States: 0
  Initial states: 0
  Final states: 0

  Transitions:
    1: From 0 to 0 labeled by (\withweighttt{1}{a})+(\withweighttt{1}{b})
\end{shell}

\noindent
States are numbered from 0, but transitions numbers start at 1.  Also,
note that weights are reported, although only \code{1} is valid for
Boolean automata.

Finally, hit \kbd{10} to save the resulting automaton in the file
\file{test.xml}.



\section{Command I/O options}

As we said in~\autoref{sec:modusoperandi}, each \tafkit command has to
read its input and write its output.  In this section we only cover
the options that may modify the Input/Output behaviors of commands.

\begin{center}
\begin{tabular}{llp{.5\textwidth}l}
  long option & short & purpose & documentation \\
  \hline
  \samp{--alphabet} & \samp{-a} & specify the alphabet of automata or rational expressions  & \autoref{sec:--alphabet}\\
  \samp{--alphabet1} & \samp{-a} & specify the first alphabet on transducers & \autoref{sec:--alphabet}\\
  \samp{--alphabet2} & \samp{-A} & specify the second alphabet on transducers & \autoref{sec:--alphabet}\\
  \samp{--input} & \samp{-i} & select input format for automata and rational expressions & \autoref{sec:formats}\\
  \samp{--output} & \samp{-o} & select output format for automata and rational expressions & \autoref{sec:formats}\\
  \samp{--parser} & \samp{-p} & fine-tune the symbols used for input and output of rational expressions and automata & \autoref{sec:writingdata}\\
\hline
\end{tabular}
 \end{center}

\noindent
The full list of options can be obtained with \kbd{vcsn-char-b --help}.

\subsection{Specifying alphabets}\label{sec:--alphabet}

When \tafkit reads an XML file, there is no need to specify any other
information besides the name of the file.  For instance when we read
\file{a1.xml} in~\autoref{sec:firstcontact} and determinized this
automaton, we did not have to tell \tafkit that the alphabet was
$\Sigma=\{a,b\}$.  The XML is self-contained and already contains this
information.

Here is a situation where specifying an alphabet is mandatory:
\begin{shell}
$ \kbd{vcsn-char-b exp-to-aut aba+a}
Error: alphabet should be explicitly defined using --alphabet
\end{shell}%$

\command{exp-to-aut} is a command that takes a rational expression and
converts it into an automaton.  To be able to parse the rational
expression, \Vauc needs to know what alphabet it its using.  Here there
is no ways it can guess whether the alphabet is $\Sigma=\{a,b\}$ and
the \samp{+} is a rational operator or if it is $\Sigma=\{a,b,+\}$ and
the \samp{+} is just a letter.  Specifying the alphabet can be done
using \option{--alphabet=ab} for instance.

\begin{shell}
$ \kbd{vcsn-char-b exp-to-aut --alphabet=ab aba+a > aut.xml}
\end{shell}%$

In practice, the long \option{--alphabet=} option can be tedious
to type and we will often prefer its short equivalent \option{-a}:

\begin{shell}
$ \kbd{vcsn-char-b exp-to-aut -aab aba+a > aut.xml}
\end{shell}%$

\paragraph{Character alphabets}

For characters alphabets (as with the \samp{char} \tafkit instances
used in the above examples), the letters of the alphabets can be
arbitrary ASCII characters, and need just to be listed after
the \samp{--alphabet=} or \samp{-a} option.

When specifying characters alphabets, some characters like \samp{ }
(space), \samp{"}, \samp{(}, \samp{)}, \samp{'}, and \samp{=} have to
be escaped with a backslash.  For instance the following command will
create an automaton that recognize numbers of the form
\samp{12,456,789}, where a comma must be used as thousand separator:
note how the comma must be escaped in the alphabet

\begin{shell}
$ \kbd{d="(0+1+2+3+4+5+6+7+8+9)"}
$ \kbd{vcsn-char-b exp-to-aut -a'0123456789\bslash,' "($d+$d$d+$d$d$d)(,$d$d$d)*" > numbers.xml}
\end{shell}%$

Some character alphabets are predefined.  These are:

\begin{center}
\begin{tabular}{ll}
\samp{letters} & The lower case letters $\{a,b,\ldots,z\}$.\\
\samp{alpha} & The upper and lower case letters $\{a,b,ldots,z,A,B,\ldots,Z\}$.\\
\samp{digit} & All digits $\{0,1,\ldots,9\}$.\\
\samp{ascii} & All ASCII characters.\\
\end{tabular}
\end{center}

\noindent
This means that \samp{-aletters} is an abbreviation for
\samp{-aabcdefghijklmnopqrstuvwxyz}.  You get always get the above
list by typing \samp{vcsn-char-b --help}.

\paragraph{Integer alphabets}

Using integers alphabets, letters must be specified as signed integer
(they are represented by the \texttt{int} C++ type), and should be
separated by commas.  For instance the following commands will
construct an automaton that reads any sequence of coins of $1$, $2$,
$5$, $10$, $20$, or $50$ cents, as long as the values are increasing.

\begin{shell}
$ \kbd{vcsn-int-b exp-to-aut -a1,2,5,10,20,50 '1*2*5*10*20*50*' > coins.xml}
\end{shell}%$

\paragraph{Pair alphabets}

Pair alphabets should be specified using parenthesis group pairs and
commas to separate the constituents of a pair.  For instance:

\begin{shell}
$ \kbd{vcsn-char-int-b exp-to-aut -a'(a,1)(b,2)(a,-1)' '(a,-1)(a,1)+(b,2)' > misc.xml}
\end{shell}%$

\paragraph{Transducer alphabets}

Free monoïd products have two alphabets, one for each monoïd.  The
instances of \tafkit that handle transducers consequently support two
options \samp{--alphabet1=} and \samp{--alphabet2=}, that can be
abbreviated respectively \samp{-a} and \samp{-A}.


\subsection{Input and Output Formats}\label{sec:formats}

\tafkit can input and output several kind of objects: automata,
rational expressions, words, weights and Boolean results.

\begin{description}
\item[words] are always read as strings given on the command line, and
  written on standard output.
\item[automata] are read from a filename specified on the command
  line, and output on standard output.  \Vauc can read automata in two
  formats: FSMXML (the default), or the textual format of FSM.  It can
  also write automata in these formats, or the \samp{dot} format, used
  for graphical output.
\item[rational expression] are by default read as strings given on the
  command line, and output as strings on standard output.
  Alternatively rational expression can be read from an FSMXML file whose
  filename is given on the command line, and output in FSMXML as well.
\item[weight results] (such as the result of the evaluation of a word on
  an automaton) are simply output as strings on the standard output
\item[Boolean results] (such as the result of asking whether an automaton
  is empty) are returned using the status code of the
  \tafkit instance, so that these commands can be used as conditions
  in shell scripts.
\end{description}

\paragraph{Changing the format for automata and rational expressions}

The format used to input automata and rational expressions can be
controlled using the \samp{--input=} and \samp{--output=} options (or
\samp{-i}, \samp{-o} for short).  These options control the I/O
formats for both automata and rational expressions at once.  So for
instance using \samp{-ixml} will ask \tafkit to read any automaton or
rational expression using the FSMXML format.  Because rational
expression are not supported in as much formats as automata, they will
be read or written as text string if an unsupported format is
requested.

\begin{center}
\begin{tabular}{lll}
  values for \samp{-i} or \samp{-o}    & format for automata & format for rational expressions \\
  \hline
  (none)     & FSMXML              & text string \\
  \samp{xml} & FSMXML              & FSMXML \\
  \samp{fsm} & FSM                 & text string \\
  \samp{dot} (for output only) & dot   & text string \\
  \hline
\end{tabular}
\end{center}

\medskip

For instance to convert an automaton from XML to dot\footnote{dot
  files can be processed using the GraphViz package}, we would use:

\begin{shell}
$ \kbd{vcsn-char-b identity -odot aut.xml > aut.dot}
\end{shell}%$


\paragraph{Verbose Boolean results}\label{sec:verbose}

As said above boolean results are returned using the program's status
code using the Unix convention (that is: $0$ for \emph{true} and any
other value for \emph{false}). The shell makes this value available in
the \samp{\$?} variable.  The \tafkit option \samp{--verbose} or \samp{-v}
can be used to request an English interpretation of this value.

\begin{shell}
$ \kbd{vcsn-int-b is-empty coins.xml}
$ \kbd{echo $?}
1
$ \kbd{vcsn-int-b is-empty -v coins.xml}
Input is not empty
\end{shell}%$

\subsection{Specifying writing data}\label{sec:writingdata}

Section~\ref{sec:emptyword} showed how the empty word and null series
can have different symbols.  \Vauc actually allows other symbols used
in rational expression to be changed.

Here is the list of named symbols with their meaning and default
values:

\begin{center}
\begin{tabular}{lll}
symbol & meaning & default value(s) \\
\hline
\samp{OPAR} & group start & \samp{(} \\
\samp{CPAR} & group end & \samp{)} \\
\samp{PLUS} & disjunction (additive law of the series) & \samp{+} \\
\samp{TIMES} & concatenation (multiplicative law of the series) & \samp{.}\\
\samp{STAR} & Kleene star & \samp{*} \\
\samp{ONE} & empty word (identity of the monoïd) & \samp{1},\samp{e},\samp{\_e},\samp{eps}\\
\samp{ZERO} & null series & \samp{0},\samp{z},\samp{\_z},\samp{zero} \\
\samp{OWEIGHT} & weight start & \samp{\{} \\
\samp{CWEIGHT} & weight end & \samp{\}} \\
\samp{SPACE} & space characters (to ignore) & \samp{ } \\
\hline
\end{tabular}
\end{center}

The \samp{--parser=} can be used to change the value of the above
tokens. Each of them must be defined as a non-empty string.  \tafkit
will check that these tokens do not collide.
For instance to use $\{(,)\}$ as alphabet, we should obviously rename
the \samp{OPAR} and \samp{CPAR} tokens.

The following command creates an automaton that recognizes the words
\samp{()}, \samp{(())}, \samp{(()())}, \samp{(()()())}, etc.


\begin{shell}
$ \kbd{vcsn-char-b -a'\(\)' --parser='OPAR=[ CPAR=]' exp-to-aut '([()]*)' >parens.xml}
\end{shell}%$

The values of these symbols, which we call the \emph{writing data},
are stored in the XML file, so there is no need to specify this again
when working from a file.

\begin{shell}
$ \kbd{vcsn-char-b aut-to-exp parens.xml}
(.(.[).(]*.).)+(.)
$ \kbd{vcsn-char-b eval parens.xml '(()())'}
1
\end{shell}%$


\paragraph{Overwriting the writing data}

When \tafkit reads an automaton or a rational expression from an XML
file (that contains writing data) or from the internal pipe, it does
not need additional information to read its input.  However the
\samp{--parser=} option can still be used to modify the way the object
will be \emph{output}.

Here is an example where we create a rational expression over the
alphabet $\{(,)\}$ using $[$ and $]$ for grouping and store it into
the file \file{p.xml}.  We can them convert this file back into a
string using either the stored writing data, or overwriting these data
with different ones (here $<$ and $>$ for grouping.

\begin{shell}
$ \kbd{vcsn-char-b -a'\(\)' --parser='OPAR=[ CPAR=]' identity-exp -oxml '([()]*)' >p.xml}
$ \kbd{vcsn-char-b identity-exp -ixml p.xml}
(.[(.)]*.)
$ \kbd{vcsn-char-b --parser='OPAR=< CPAR=>' identity-exp -ixml p.xml}
(.<(.)>*.)
\end{shell}%$

\noindent the command \command{indentity-exp} used in the above
example does not apply any algorithm on the rational expression.  Its
only purpose is to read and write the rational expression using any
I/O option supplied on the command-line.\footnote{When reading a
  rational expression, trivial identities are also rewritten. (FIXME:
  ref).}

%%%% This is really too much detail, with no obvious usage.
%%%%
%% You can also use the \verb-ALPHABET- token an arbitrary number of
%% times, to append letters to the current alphabet. The following
%% commands:
%%
%% %% FIXME: include ({1} a) in the example
%% \begin{shell}
%% $ \kbd{vcsn-char-b --alphabet=ab exp-to-aut '((a) + b)*' >parser.xml}
%% \end{shell}
%% \begin{shell}
%% $ \kbd{vcsn-char-b --output-type=dot identity parser.xml >parser.dot}
%% \end{shell}
%%
%% \noindent
%% will give the same results as:
%% %% FIXME: include ({1} a) in the example
%% \begin{shell}
%% $ \kbd{vcsn-char-b --alphabet=a --parser="ALPHABET=b ONE=e STAR=star" exp-to-aut '(a + b)star' >parser2.xml}
%% \end{shell}
%% \begin{shell}
%% $ \kbd{vcsn-char-b --output-type=dot identity parser2.xml >parser2.dot}
%% \end{shell}
%%
%% \noindent
%% With the \verb-ALPHABET- token, you can specify two types of letters:
%%
%% \begin{itemize}
%% \item letters: one character is used to represent a letter.
%% \item words: many characters are used to represent a letter.
%% \end{itemize}
%%
%% For example, \verb-ALPHABET=letters:abc- defines the alphabet with three letters
%% $\{\verb-a-, \verb-b-, \verb-c-\}$, while \verb-ALPHABET=words:abc- defines the
%% alphabet with only one letter $\{\verb-abc-\}$. Letters are separated by commas, and
%% each \tafkit context defaults to either letters (vcsn-char-b eg) or words
%% (vcsn-int-b eg). \verb|vcsn-int-b --alphabet=0,1,2,3,4,5,6,7,8,9| and
%% \verb|vcsn-int-b --alphabet=letters:0123456789'| will give the same alphabets.
%%
%% Everywhere you want to use special characters used by the \verb|--parser|
%% option, prepending a backslash character will escape it. So, you can write:
%% \verb|ALPHABET=\,,\=| which defines the alphabet with the two letters \verb-,-
%% and \verb-=-.
%%
%% Finally whenever you may put a single character you may write a pair a words.
%% The following construction is then valid: \verb|ALPHABET=(\,,\))|, and defines
%% the alphabet with only one letter: the pair whose first component is \verb-,-
%% and the second one is \verb-)-.
%%
%% For more details, the grammar of the \verb|--parser| option is included in the
%% source code in EBNF notations.


\section{Transducers}
\label{sec:vcsn-char-fmp-b}

While the \Vauc library supports two views of transducers, currently
\tafkit only provides one view:

\begin{description}
\item[vcsn-char-fmp-b] considering a transducer as a weighted automaton of a
  product of free monoid,
\end{description}

In a forthcoming release, \tafkit will provide:

\begin{description}
\item[vcsn-char-rw] considering a transducer as a machine that takes a
  word as input and produce another word as (two-tape automata).
\end{description}

Both views are equivalent and \Vauc provides algorithms to pass from a
view to the other one.

\subsection{Example}

\begin{figure}[tp]
  \begin{center}
    \begin{tikzpicture}[automaton]
      % states
      \node[state, initial left, accepting below] (A) at (0,0) {};
      \node[state] (B) at (3,0) {};
      \node[state] (C) at (6,0) {};
      % transitions
      \path[->] (A) edge [loop above] node[above] {$\IOL{0}{0}$} (A);
      \path[->] (C) edge [loop above] node[above] {$\IOL{1}{1}$} (C);
      \path[->] (A) edge [bend left] node[above] {$\IOL{1}{0}$} (B);
      \path[->] (B) edge [bend left] node[above] {$\IOL{1}{1}$} (A);
      \path[->] (B) edge [bend left] node[above] {$\IOL{0}{0}$} (C);
      \path[->] (C) edge [bend left] node[above] {$\IOL{0}{1}$} (B);
    \end{tikzpicture}
    \begin{legend}
      The transducer computing the quotient by 3 of a binary number.
    \end{legend}
    \caption{Rational-weight transducer $\Tc_1$}
    \label{fig:t1}
  \end{center}
\end{figure}

%% \begin{figure}[tp]
%%   \begin{center}
%
%%\begin{tikzpicture}[automaton]
%%  % states
%%  \node[state, initial left] (A) at (0,0) {};
%%  \node[state, accepting right] (B) at (3,0) {};
%%  \FinalL{s}{A}{(,1)}
%%  % transitions
%%  \path[->] (A) edge [loop above] node[above] {$(1,0)$} (A);
%%  \path[->] (B) edge [loop above] node[above] {$(1,1)$} (B);
%%  \path[->] (B) edge [loop below] node[below] {$(0,0)$} (B);
%%  \path[->] (A) edge node[above] {$(0,1)$} (B);
%%  \end{tikzpicture}
%%}
%%     \caption{Transducer $\Tc_2$ adding 1 to a binary number}
%%     \label{fig:t2}
%%   \end{center}
%% \end{figure}

To experiment with transducers, we will use \index{T1@$\Tc_1$}$\Tc_1$,
described in \autoref{fig:t1}, and part of the automaton library
(\autoref{char-fmp-b:t1}).

%% \subsubsection{Evaluation}
%%
%% Currently \tafkit requires the user to specify the alphabets to use
%% using \option{--alphabet1} and \option{--alphabet2}.
%%
%% \begin{shell}
%% $ \kbd{vcsn-char-fmp-b --alphabet1=ab eval t1.xml 'bba'}
%% \end{shell}

\subsubsection{Domain}
The transducer $T$ only accepts binary numbers divisible by 3.

\begin{shell}
$ \kbd{vcsn-char-fmp-b identity-nodep t1.xml | vcsn-char-fmp-b --alphabet1=ab domain - >div-by-3.xml}
\end{shell}

Now the file \file{divisible-by-3.xml} contains the description of a
Boolean automaton that accepts only the numbers divisible by 3:

\begin{shell}
$ \kbd{vcsn-char-b --output-type=dot identity div-by-3.xml >div-by-3.dot}
\end{shell}


%% \subsubsection{to-tdc}
%% Each transducer can be transformed to the other type of transducer
%% thanks to the \taffn{to-tdc} and \taffn{to-rw-tdc} functions.
%% \begin{shell}
%% $ \kbd{vcsn-char-rw to-tdc quot_3_rw.xml > quot_3.xml}
%% $ \kbd{vcsn-char-fmp-b to-rw-tdc add1.xml > add1_rw.xml}
%% \end{shell}
%%
%% \subsubsection{Composing}
%% \begin{shell}
%% $ \kbd{vcsn-char-fmp-b compose quot_3.xml add1.xml}
%% \end{shell}

\subsection{Available functions}
The following functions are available for both \command{vcsn-char-rw}
and \command{vcsn-char-fmp-b} programs.  To invoke them, run
\samp{\var{program} \var{algorithm-name} [\var{arguments}]}.

\begin{shell}
$ \kbd{vcsn-char-fmp-b --list-commands}
\end{shell}

%% In the following:
%%
%% \begin{itemize}
%% \item \var{t1} and \var{t2} are two transducers (either ``rational-weight''
%%   or not) described in \Vauc XML format;
%% \item \var{w} is a word, for example \samp{"aabb"} if you are working
%%   on an alphabet that contains the letters \samp{a} and \samp{b};
%% \item \var{a} is a Boolean automaton;
%% \item \var{t1-rw} is a rational-weight transducer;
%% \item \var{t1-fmp} is a transducer (seen as an automaton over a free
%%   monoid product).
%% \end{itemize}
%%
%% \begin{fnsection}{Input/output work with transducers}
%% \item{define-automaton}{}{Define a transducer from scratch.}
%% \item{edit-automaton}{t1}{Edit an existing transducer.}
%% \item{info}{t1}{Print the number of states, transitions, initial and
%%     final states of \var{t1}.}
%% \item{display}{t1}{Display the transducer using DOTTY.}  \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Tests and evaluation on transducers}
%% \item{are-isomorphic}{t1 t2}{Test if the two transducers are
%%     isomorphic.}
%% \item{evaluation}{t1 w}{Compute the evaluation of \var{w} by
%%     \var{t1}.}
%% \item{is-empty}{t1}{Test if \var{t1} realizes the empty relation.}
%%   \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Generic algorithm for transducers}
%% \item{closure}{t1}{$\varepsilon$-removal algorithm.}
%%
%% \item{compose}{t1 t2}{Compute a transducer realizing $f_2 \circ f_1$,
%%     where $f_1$ (resp. $f_2$) is the function associated to \var{t1}
%%     (resp. \var{t2}).}
%%
%% \item{domain}{t1}{Compute an automaton accepting all input accepted by
%%     the transducer t1.}
%%
%% \item{evaluation}{t1}{Compute the evaluation of w by t1.}
%%
%% \item{evaluation-aut}{t1}{Compute a Boolean automaton describing the
%%     words produced by the language described by a evaluated by t1.}
%%
%% \item{image}{t1}{Compute an automaton describing all output produced
%%     by the transducer t1.}
%%
%% %\item{transpose}{t1}{Compute the transposed of the transducer t1.}
%%
%% \item{trim}{t1}{Compute the trimmed transducer of t1.}  \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Algorithms for transducers}
%% \item{sub-normalize}{t1-fmp}{Compute the sub-normalized transducer of
%%     \var{t1-fmp}.}
%% \item{is-sub-normalized}{t1-fmp}{Test if \var{t1-fmp} is
%%     sub-normalized.}
%% \item{composition-cover}{t1-fmp}{.}%%FIXME
%% \item{composition-co-cover}{t1-fmp}{.}%%FIXME
%% \item{b-compose}{t1-fmp t2-fmp}{Compose \var{t1-fmp} and
%%     \var{t2-fmp}, two unweighted normalized or sub-normalized
%%     transducers.}
%% \item{to-rw-tdc}{t1-fmp}{Compute the equivalent realtime transducer
%%     of \var{t1-fmp}.}
%% \item{intersection}{a}{Transform \var{a} in a fmp transducer by
%%     creating, for each word, a pair containing twice this word.}
%%   \hline
%% \end{fnsection}
%%
%%
%% \begin{fnsection}{Algorithms for ``realtime'' transducers}
%% \item{realtime}{t1-rw}{Compute the realtime transducer of  \var{t1-rw}.}
%% \item{is-realtime}{t1-rw}{Test if \var{t1-rw} is realtime.}
%% \item{to-tdc}{t1-rw}{Compute the equivalent fmp transducer of \var{t1-rw}.}
%% \hline
%% \end{fnsection}

\newpage
\section{\Z-Automata}
\label{sec:vcsn-char-z}

This part shows the use of the program \Index{\command{vcsn-char-z}}, but
all comments should also stand for the programs
\command{vcsn-char-z-min-plus} and \command{vcsn-char-z-max-plus}.

Again, we will toy with some of the automata provided by
\command{vcsn-char-z}, see \autoref{sec:auto:char-z}.

\subsection{Counting \samp{b}s}

\begin{figure}[tp] \centering
  \begin{tikzpicture}[automaton]
    % states
    \node[state, initial] (A) at (0,0) {};
    \node[state, accepting] (B) at (3,0) {};
    % initial--final
    % transitions
    \path[->] (A) edge node[above] {$b$} (B);
    \path[->] (A) edge [loop below] node[below] {$b$} (A);
    \path[->] (A) edge [loop above] node[above] {$a$} (A);
    \path[->] (B) edge [loop below] node[below] {$b$} (B);
    \path[->] (B) edge [loop above] node[above] {$a$} (B);
  \end{tikzpicture}
  \begin{legend}
    Considered without weight, $\Bc_1$ accepts words with a \samp{b}.
    With weights, it counts the number of \samp{b}s.
    \index{B1@$\Bc_1$}
  \end{legend}
  \caption{The automaton $\Bc_1$}
  \label{fig:b1}
\end{figure}

Let's consider $\Bc_1$ (\autoref{fig:b1}), an
\index{N-automaton@$\mathbb{N}$-automaton}$\mathbb{N}$-automaton,
\textit{i.e.}  an automaton whose label's weights are in $\mathbb{N}$.
This time the evaluation of the word \var{w} by the automaton
$\Bc_1$ will produce a number, rather than simply accept or
reject \var{w}.  For instance let's evaluate \samp{abab} and
\samp{bbab}:

\begin{shell}
$ \kbd{vcsn-char-z identity-nodep b1.xml | vcsn-char-z eval - 'abbb'}
\end{shell}
\begin{shell}
$ \kbd{vcsn-char-z identity-nodep b1.xml | vcsn-char-z eval - 'abab'}
\end{shell}

\noindent
Indeed, $\Bc_1$ counts the number of \samp{b}s.

\subsubsection{Power}

Now let's consider the $\Bc_1^n$, where
\begin{displaymath}
  \Bc_1^n = \prod_{i=1}^n \Bc_1, n > 0
\end{displaymath}

\noindent
This is implemented by the \Index{\taffn{power}} function:

\begin{shell}
$ \kbd{vcsn-char-z identity-nodep b1.xml | vcsn-char-z power - 4 >b4.xml}
\end{shell}
\begin{shell}
$ \kbd{vcsn-char-z power b1.xml 4 > b4.xml}
\end{shell}

\noindent
The file \file{b4.xml} now contains the automaton $\Bc_1^4$.  Let's
check that the evaluation of the words \samp{abab} and \samp{bbab} by
$\Bc_1^4$ gives the fourth power of their evaluation by $\Bc_1$:

\begin{shell}
$ \kbd{vcsn-char-z eval b4.xml 'abbb'}
\end{shell}
\begin{shell}
$ \kbd{vcsn-char-z eval b4.xml 'abab'}
\end{shell}

\subsubsection{Quotient}

Successive products of an automaton create a lot of new states and
transitions.

\begin{shell}
$ \kbd{vcsn-char-z identity-nodep b1.xml | vcsn-char-z info -}
\end{shell}
\begin{shell}
$ \kbd{vcsn-char-z info b4.xml}
\end{shell}

One way of reducing the size of our automaton is to use the
\Index{\taffn{quotient}} algorithm.

\begin{shell}
$ \kbd{vcsn-char-z quotient b4.xml | vcsn-char-z info -}
\end{shell}



\chapter{Automaton Repository}

\Vauc comes with a set of interesting automata that can be used to toy
with \tafkit (\autoref{sec:tafkit}) for instance.  In this chapter, we
present each one of these automata.

\section{\B{} automata}

\subsection{\file{a1.xml} ($\Ac_1$)}

\begin{tikzpicture}[automaton]
  % states
  \node[state, initial] (A) at (0,0) {};
  \node[state] (B) at (2,0) {};
  \node[state, accepting] (C) at (4,0) {};
  % initial--final
  % transitions
  \path[->] (A) edge node[above] {$a$} (B);
  \path[->] (B) edge node[above] {$b$} (C);
  \path[->] (A) edge [loop below] node[below] {$b$} (A);
  \path[->] (A) edge [loop above] node[above] {$a$} (A);
  \path[->] (C) edge [loop below] node[below] {$b$} (C);
  \path[->] (C) edge [loop above] node[above] {$a$} (C);
\end{tikzpicture}

The automaton $\Ac_1$, defined over the alphabet $\Sigma=\{a,b\}$,
recognizes any word of $\Sigma^\star$ that contains $ab$.

\subsection{\file{b1.xml} $\Bc_1$}
\subsection{\file{div3base2.xml}}

The \command{divkbaseb} program....

\subsection{\file{double-3-1.xml}}

The \command{double\_ring} program....

\subsection{\file{ladybird-6.xml}}

The \command{ladybird} program....



\section{\Z{} automata}

\section{\B{} FMP}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% ispell-local-dictionary: "american"
%%% End:

% LocalWords:  priori semiring monoids tafkit
% LocalWords:  svn vaucanson cd sudo
% LocalWords:  determinize vcsn semiring rw tdc TAF aut dmi determinizes bz xml
% LocalWords:  det detmin eval abab bbba aabb determinized Hopcroft aab fmp dom
% LocalWords:  Glushkov thompson realtime bbab abbb monoids zmin zmax
% LocalWords:  semiring ite Glushkov Rouen Kleene Schutzenberger mutatis
% LocalWords:  mutandis Kleene's Hadamard
