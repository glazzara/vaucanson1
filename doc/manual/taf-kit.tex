\chapter{The \Vauc toolkit}
\label{sec:tafkit}

This chapter prevents a simple interface to \Vauc: a set of programs
tailored to be used from a traditional shell.  Since they exchange
\emph{typed} XML files, there is one program per automaton type.  Each
program supports a set of operations which depends on the type of the
automaton.

Many users of automata consider only automata whose transitions are
labeled by letters taken in an alphabet, which we call, roughly
speaking, \emph{classical} automata or \emph{Boolean} automata.  The
first program of the \tafkit, \command{vcsn-b}, allows to compute with
classical automata and is described in \autoref{sec:vcsn-b}.

\autoref{sec:vcsn-tdc} describes the program \command{vcsn-tdc} which
allows to compute with transducers, that is, automata whose
transitions are labeled by pair of words, which are elements of a
\emph{product of free monoids}, hence the name.

In \autoref{sec:vcsn-z} we consider the programs of the \tafkit that
compute with automata over a free monoid and with multiplicity, or
\emph{weight} taken in the set of integers equipped with the usual
operations of addition and multiplication, that is, the semiring $\Z$,
or with the operations of $\min$ and addition, or the operations of
$\max$ and addition, that is, the semirings $\Z,\min,+$ and
$\Z,\max,+$.  Finally, the forth section describes the program
\command{vcsn-rw-tdc} which allows to compute with transducers, viewed
as automata on a free monoid (the input monoid) with multiplicity
taken in the semiring of finite and even rational subsets of another
free monoid (the output monoid).

\medskip


It is planned that a forthcomming version will include also:

\begin{description}
\item[vcsn-zmin] for automata over a free monoid with multiplicity in
  the semiring (\Z, \min, +)

\item[vcsn-zmax] for automata over a free monoid with multiplicity in the
  semiring (\Z, \max, +)

\item[vcsn-rw-tdc] for transducers viewed as automata over a free
  monoid with multiplicity in the semiring of rational sets (or
  series) over (another) free monoid.
\end{description}

\newpage

\section{Boolean automata}
\label{sec:vcsn-b}

This section focuses on the program \Index{\command{vcsn-b}}, the
\tafkit component dedicated to Boolean automata.

\subsection{First Contacts}

\command{vcsn-b} and its peer components of \tafkit all share the same
simple interface:

\begin{shell}
# vcsn-b \var{function} \var{automaton} \var{arguments...}
\end{shell}

\noindent
The \var{function} is the name of the operation to perform on the
\var{automaton}, specified as an XML file.  Some functions, such as
evaluation, will require additional arguments, such as the word to
evaluate.  Some other functions, such as \samp{exp-to-aut} do not have
an \var{automaton} argument.

\tafkit is made to work with Unix \emph{pipes}, that is to say, chains
of commands which feed each other.  Therefore, all the functions
produce a result on the standard output, and if an \var{automaton} is
\samp{-}, then the standard input is used.

\smallskip

A typical line of commands from the \tafkit reads as follows:
\begin{shell}
# \kbd{vcsn-b determinize a1.xml > a1det.xml}
\end{shell}
and should be understood, or analysed, as follows.
\begin{enumerate}
\item \command{vcsn-b} is the call to a \command{shell} command
  that will launch a \Vauc function.  \command{vcsn-b} has 2
  arguments, the first one being the \var{function} which will be
  launched, the second being the \var{automaton} that is the input
  argument of the \var{function}.

\item \taffn{determinize} is, as just said, a \Vauc function.  And as
  it can easily be guessed, \taffn{determinize} takes an
  \var{automaton} as argument, performs the subset construction on it
  and outputs the result on the standard output.

\item \file{a1.xml} is the description of an automaton --- of the
  automaton of \autoref{b:a1} indeed --- in an XML format that is
  understood\footnote{%
    This format is not exactly part of the \Vauc platform.  It has
    been developped for providing a mean of communication between
    various softwares dealing with automata.  And then it has been
    used as a communication tool between the invocation of \Vauc
    function by the \tafkit.  A lay user of the \tafkit should not
    need to know how this format is defined but a rouh description of
    it is provided at \autoref{sec:xml} of the Appendix.}  by \Vauc.
  Which means that this file must exist before the line is executed.
  The \file{data/automata} directory provides a number of XML files
  for examples of automata, a number of programs that produce the XML
  files for automata whose definition depend upon some variables and
  the \tafkit itself allow to define automata and thus to produce the
  corresponding XML files (cf. below).

\item \verb+ > + \file{a1det.xml} puts the result of
  \taffn{determinize} \samp{a1.xml}, that is, the XML file which
  describes the determinized automaton of $\Ac_{1}$ into the file
  \file{a1det.xml}.
\end{enumerate}

\bigskip

As a more elaborate example, consider the following command

\execcaption{a1dmi}{vcsn-b dump-automaton a1 | vcsn-b determinize - | vcsn-b minimize - | vcsn-b info -}

\noindent
It fetches the automaton \code{a1} from the automaton library,
determinizes it, minimizes the result, and finally displays
information about the resulting automaton.

Please, note the typographic conventions: user input is represented
\texttt{\# \kbd{like this}}, standard output follows \texttt{like
  this}, followed by standard error output \texttt{error: like this},
and finally, if different from 0, the exit status is represented
\texttt{=> like this}.  For instance:

\execcaption{bz-mismatch}{vcsn-b dump-automaton a1 | vcsn-z info -}

\smallskip

Other than that, the interface of the \tafkit components is usual,
including options such as \option{--version} and \option{--help}:

\execcaption{vcsn-b-help}{vcsn-b --help}

The whole list of supported commands is available via
\option{--list-commands}.

\subsection{A first example}

\Vauc provides a set of common automata.  The function
\Index{\taffn{list-automata}} lists them all:

\execcaption{b-list}{vcsn-b list-automata}

\begin{figure}[ht] \centering
  \begin{VCPicture}{(0,-2)(6,2)}
    % states
    \State{(0,0)}{A}
    \State{(3,0)}{B}
    \State{(6,0)}{C}
    % initial--final
    \Initial{A}
    \Final{C}
    % transitions
    \EdgeL{A}{B}{a}
    \EdgeL{B}{C}{b}
    \LoopS[.5]{A}{b}
    \LoopN[.5]{A}{a}
    \LoopS[.5]{C}{b}
    \LoopN[.5]{C}{a}
  \end{VCPicture}
  \begin{legend}
    The graphical layout of this automaton was described by hand,
    using the Vaucanson-G \LaTeX{} package.  However, the following
    figures are generated by \tafkit, giving a very nice layout, yet
    slightly less artistic.

    The automaton is taken from \citet[Fig. I.1.1, p.
    58]{sakarovitch.03.eta}.\index{A1@$\Ac_1$}
  \end{legend}
  \caption{The automaton $\Ac_1$}
  \label{fig:a1}
\end{figure}

Let's consider the Boolean automaton $\Ac_1$
(\autoref{fig:a1}), part of the standard library.  It can be dumped
using \Index{\taffn{dump-automaton}}:

\execcaption{a1-dump}{vcsn-b dump-automaton a1}

Usual shell indirections (\samp{|}, \samp{>}, and \samp{<}) can be
used to combine \tafkit commands.  For instance, this is an easy means
to bring a local copy of this file:

\execcaption{a1-xml}{vcsn-b dump-automaton a1 >a1.xml}

\tafkit uses XML to exchange automata, to get graphical rendering of
the automaton, you may either invoke \Index{\taffn{dot-dump}} and then
use a Dot compliant program, or use \Index{\taffn{display}} that does
both.

\execcaption{a1-dot}{vcsn-b dot-dump a1.xml >a1.dot}
\begin{center}
  \includegenerateddot{a1}
\end{center}


\subsubsection{Determinization of $\Ac_1$}
To determinize a Boolean automaton, call the
\Index{\taffn{determinize}} function:

\execcaption{a1det}{vcsn-b dump-automaton a1 | vcsn-b determinize - >a1det.xml}

To get information about an automaton, call the \Index{\taffn{info}} function:
\execcaption{a1det-info}{vcsn-b info a1det.xml}

Or use dotty to visualize it:
\execcaption{a1det.dot}{vcsn-b dot-dump a1det.xml >a1det.dot}
\begin{center}
  \includegenerateddot{a1det}
\end{center}

\subsubsection{Minimizing}

The \index{\taffn{minimize}}minimal automaton can be computed the same way:
\execcaption{a1detmin}{vcsn-b minimize a1det.xml >a1detmin.xml}
\execcaption{a1detmin.dot}{vcsn-b dot-dump a1det.xml >a1detmin.dot}
\begin{center}
  \includegenerateddot{a1detmin}
\end{center}

The commands can be composed with pipes from the shell, using
\Index{\samp{-}} to denote the standard input.
\begin{shell}
# vcsn_b determinize a1.xml | vcsn_b minimize - > a1_min.xml
\end{shell}


\subsubsection{Evaluation}

To \index{\taffn{eval}}evaluate whether a word is accepted:

\execcaption{a1.abab}{vcsn-b eval a1.xml 'abab'}
\execcaption{a1.bbba}{vcsn-b eval a1.xml 'bbba'}

\noindent
where 1 (resp. 0) means that the word is accepted (resp. not accepted)
by the automaton.

\subsection{Rational expressions and Boolean automata}

\Vauc provides functions to manipulate rational expressions associated
to Boolean automata. For instance, computing the language recognized
by a Boolean automaton can be done using \Index{\taffn{aut-to-exp}}:

\execcaption{a1.rat}{vcsn-b aut-to-exp a1.xml}
\execcaption{a1det.rat}{vcsn-b aut-to-exp a1det.xml}

\Vauc provides several algorithms that build an automaton that
recognizes a given language.  The following sequence computes the
minimal automaton of \samp{(a+b)*ab(a+b)*}.

\execcaption{l1}{vcsn-b --alphabet=ab standard "(a+b)*a.b.(a+b)*" | vcsn-b minimize - >l1.xml}
\execcaption{l1.dot}{vcsn-b dot-dump l1.xml >l1.dot}
\begin{center}
  \includegenerateddot{l1}
\end{center}

\subsection{Available functions}
%% Une definition plus rigoureuse des algorithmes devrait etre fournie
%% en annexe.
This section gives a brief definition of all functions that \Vauc
provides for manipulating Boolean automata.  All these algorithms are
invoked using \samp{vcsn-b \var{algorithm-name} [\var{arguments}]}. If
the argument is replaced by \samp{-} then the program will read an
argument from the standard input.  All algorithms dump their result to
the standard output, except the ``tests'' functions that also return
an exit status (0 if the test is successful, anything else otherwise).

\execcaption{vcsn-b-commands}{vcsn-b --list-commands}


%% In the following:
%% \begin{itemize}
%% \item \var{a1} and \var{a2} are two Boolean automata described
%%   in \Vauc XML format;
%% \item \var{w} is a word, for example \samp{"aabb"} if you are
%%   working on an alphabet that contains the letters \samp{a} and
%%   \samp{b};
%% \item \var{exp} is a rational expression denoting a language;
%% \item \var{n} is a non-negative integer.
%% \end{itemize}
%%
%%
%% \begin{fnsection}{Input/output work with automata}
%% \item{define-automaton}{}{Define an automaton from scratch.}
%% \item{edit-automaton}{a1}{Edit an existing automaton.}
%% \item{info}{a1}{Print the number of states, transitions, initial and
%%     final states of \var{a1}.}
%% \item{display}{a1}{Display the automaton using Dotty.}
%% \item{dump}{a1}{Dump the automaton to Dot format.}  \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Tests and evaluation on automata}
%% \item{are-isomorphic}{a1 a2}{Test whether \var{a1} and \var{a2} are
%%     isomorphic.}
%% \item{evaluation}{a1 w}{Test whether the word \var{w} is accepted by
%%     \var{a1}.}
%% \item{is-deterministic}{a1}{Test whether \var{a1} is deterministic.}
%% \item{is-empty}{a1}{Test whether \var{a1} accepts no word.}  \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Generic algorithms for automata}
%% \item{accessible}{a1}{Extract the sub-automaton of accessible states
%%     of \var{a1}.}
%% \item{co-accessible}{a1}{Extract the sub-automaton of co-accessible
%%     states of \var{a1}.}
%% \item{trim}{a1}{Trim the automaton \var{a1}.}
%% \item{transpose}{a1}{Compute the automaton accepting the mirror
%%     language of the one accepted by \var{a1}.}
%%
%% \item{closure}{[-bf] a1}{$\varepsilon$-removal algorithm.}
%%   & \option{-b} : backward closure\\
%%   & \option{-f} : forward closure\\
%% \item{concatenate}{a1 a2}{Concatenate \var{a1} to \var{a2}.}
%% \item{sum}{aut1 aut2}{Compute the sum of \var{a1} and \var{a2}.}
%% %\item{normalize}{aut1}{Compute an automaton with unique initial and
%% %    final states, with $\varepsilon$-transitions.}
%% %\item{standardize}{aut1}{Compute an automaton with unique initial
%% %    state without adding $\varepsilon$-transitions.}  \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Generic algorithms for automata on letters}
%% \item{rational-weight}{[-bf] a1}{$\varepsilon$-removal algorithm and make
%%     every transition labeled by a letter.}
%%   & \option{-b} : backward closure\\
%%   & \option{-f} : forward closure\\
%% \item{product}{a1 a2}{Compute the (Cartesian) product of \var{a1} and
%%     \var{a2}.}
%% \item{power}{a1 n}{Compute the (Cartesian) product of \var{a1} by
%%     itself \var{n} times.}
%% \item{quotient}{a1}{Compute the minimal automaton in bi-simulation
%%     with \var{a1}.}  \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Algorithms specific to Boolean automata}
%% \item{determinize}{a1}{Compute the determinized automaton of
%%     \var{a1}.}
%% \item{complement}{a1}{Compute an automaton that accepts the complement
%%     language of the one accepted by \var{a1}.}
%% \item{minimize}{[-hm] a1}{Minimize the {\em deterministic} automaton
%%     \var{a1}.}
%%   & \option{-h} : use the Hopcroft algorithm\\
%%   & \option{-m} : use the Moore algorithm\\
%%   \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Conversion between automata and expressions}
%% \item{aut-to-exp}{a1}{Print a rational expression denoting the
%%     language accepted by \var{a1}.}
%% \item{expand}{exp}{Partially expand rational expressions. For
%%     instance, expanding \samp{a(b+ab(a+b))} will produce
%%     \samp{aab.(a+b)*+ab}}
%% \item{derived-term}{exp}{Compute the derived term automaton of
%%     \var{exp}.}
%% \item{standard}{exp}{Compute the standard (Glushkov) automaton of
%%     \var{exp}.}
%% \item{thompson-of}{exp}{Compute the Thompson automaton of \var{exp}.}
%%   \hline
%% \end{fnsection}
%%

\newpage
\section{Transducers}
\label{sec:vcsn-tdc}

While the \Vauc library supports two views of transducers, currently
\tafkit only provides one view:

\begin{description}
\item[vcsn-tdc] considering a transducer as a weighted automaton of a
  product of free monoid,
\end{description}

In a forthcoming release, \tafkit will provide:

\begin{description}
\item[vcsn-rw-tdc] considering a transducer as a machine that takes a
  word as input and produce another word as (two-tape automata).
\end{description}

Both views are equivalent and \Vauc provides algorithms to pass from a
view to the other one.

\subsection{Example}

\begin{figure}[tp]
  \begin{center}
    \begin{VCPicture}{(0,-2)(6,2)}
      % states
      \State{(0,0)}{A} \State{(3,0)}{B} \State{(6,0)}{C}
      \Initial[w]{A}
      \Final[s]{A}
      % transitions
      \LoopN[.5]{A}{\IOL{0}{0}}
      \LoopN[.5]{C}{\IOL{1}{1}}
      \ArcL{A}{B}{\IOL{1}{0}}
      \ArcL{B}{A}{\IOL{1}{1}}
      \ArcL{B}{C}{\IOL{0}{0}}
      \ArcL{C}{B}{\IOL{0}{1}}
    \end{VCPicture}
    \begin{legend}
      The transducer computing the quotient by 3 of a binary number.
    \end{legend}
    \caption{Rational-weight transducer $\Tc_1$}
    \label{fig:t1}
  \end{center}
\end{figure}

%% \begin{figure}[tp]
%%   \begin{center}
%%     \begin{VCPicture}{(0,-2)(3,2)}
%%       % states
%%       \State{(0,0)}{A} \State{(3,0)}{B}
%%       \Initial[w]{A}
%%       \FinalL{s}{A}{(,1)}
%%       \Final[e]{B}
%%       % transitions
%%       \LoopN[.5]{A}{(1,0)}
%%       \LoopN[.5]{B}{(1,1)}
%%       \LoopS[.5]{B}{(0,0)}
%%       \EdgeL{A}{B}{(0,1)}
%%     \end{VCPicture}
%%     \caption{Transducer $\Tc_2$ adding 1 to a binary number}
%%     \label{fig:t2}
%%   \end{center}
%% \end{figure}

To experiment with transducers, we will use \index{T1@$\Tc_1$}$\Tc_1$,
described in \autoref{fig:t1}, and part of the automaton library
(\autoref{tdc:t1}).

%% \subsubsection{Evaluation}
%%
%% Currently \tafkit requires the user to specify the alphabets to use
%% using \option{--alphabet1} and \option{--alphabet2}.
%%
%% \execcaption{t1.110}{vcsn-tdc --alphabet1=ab eval t1.xml 'bba'}

\subsubsection{Domain}
The transducer $T$ only accepts binary numbers divisible by 3.

\execcaption{t1.dom}{vcsn-tdc dump-automaton t1 | vcsn-tdc --alphabet1=ab domain - >div-by-3.xml}

Now the file \file{divisible-by-3.xml} contains the description of a
Boolean automaton that accepts only the numbers divisible by 3:

\execcaption{div-by-3.dot}{vcsn-b dot-dump div-by-3.xml >div-by-3.dot}
\includegenerateddot{div-by-3}


%% \subsubsection{to-tdc}
%% Each transducer can be transformed to the other type of transducer
%% thanks to the \taffn{to-tdc} and \taffn{to-rw-tdc} functions.
%% \begin{shell}
%% # vcsn-rw-tdc to-tdc quot_3_rw.xml > quot_3.xml
%% # vcsn-tdc to-rw-tdc add1.xml > add1_rw.xml
%% \end{shell}
%%
%% \subsubsection{Composing}
%% \begin{shell}
%% # vcsn-tdc compose quot_3.xml add1.xml
%% \end{shell}

\subsection{Available functions}
The following functions are available for both \command{vcsn-rw-tdc}
and \command{vcsn-tdc} programs.  To invoke them, run
\samp{\var{program} \var{algorithm-name} [\var{arguments}]}.

\execcaption{vcsn-tdc-commands}{vcsn-tdc --list-commands}

%% In the following:
%%
%% \begin{itemize}
%% \item \var{t1} and \var{t2} are two transducers (either ``rational-weight''
%%   or not) described in \Vauc XML format;
%% \item \var{w} is a word, for example \samp{"aabb"} if you are working
%%   on an alphabet that contains the letters \samp{a} and \samp{b};
%% \item \var{a} is a Boolean automaton;
%% \item \var{t1-rw} is a rational-weight transducer;
%% \item \var{t1-fmp} is a transducer (seen as an automaton over a free
%%   monoid product).
%% \end{itemize}
%%
%% \begin{fnsection}{Input/output work with transducers}
%% \item{define-automaton}{}{Define a transducer from scratch.}
%% \item{edit-automaton}{t1}{Edit an existing transducer.}
%% \item{info}{t1}{Print the number of states, transitions, initial and
%%     final states of \var{t1}.}
%% \item{display}{t1}{Display the transducer using DOTTY.}  \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Tests and evaluation on transducers}
%% \item{are-isomorphic}{t1 t2}{Test if the two transducers are
%%     isomorphic.}
%% \item{evaluation}{t1 w}{Compute the evaluation of \var{w} by
%%     \var{t1}.}
%% \item{is-empty}{t1}{Test if \var{t1} realizes the empty relation.}
%%   \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Generic algorithm for transducers}
%% \item{closure}{t1}{$\varepsilon$-removal algorithm.}
%%
%% \item{compose}{t1 t2}{Compute a transducer realizing $f_2 \circ f_1$,
%%     where $f_1$ (resp. $f_2$) is the function associated to \var{t1}
%%     (resp. \var{t2}).}
%%
%% \item{domain}{t1}{Compute an automaton accepting all input accepted by
%%     the transducer t1.}
%%
%% \item{evaluation}{t1}{Compute the evaluation of w by t1.}
%%
%% \item{evaluation-aut}{t1}{Compute a Boolean automaton describing the
%%     words produced by the language described by a evaluated by t1.}
%%
%% \item{image}{t1}{Compute an automaton describing all output produced
%%     by the transducer t1.}
%%
%% %\item{transpose}{t1}{Compute the transposed of the transducer t1.}
%%
%% \item{trim}{t1}{Compute the trimmed transducer of t1.}  \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Algorithms for transducers}
%% \item{sub-normalize}{t1-fmp}{Compute the sub-normalized transducer of
%%     \var{t1-fmp}.}
%% \item{is-sub-normalized}{t1-fmp}{Test if \var{t1-fmp} is
%%     sub-normalized.}
%% \item{composition-cover}{t1-fmp}{.}%%FIXME
%% \item{composition-co-cover}{t1-fmp}{.}%%FIXME
%% \item{b-compose}{t1-fmp t2-fmp}{Compose \var{t1-fmp} and
%%     \var{t2-fmp}, two unweighted normalized or sub-normalized
%%     transducers.}
%% \item{to-rw-tdc}{t1-fmp}{Compute the equivalent realtime transducer
%%     of \var{t1-fmp}.}
%% \item{intersection}{a}{Transform \var{a} in a fmp transducer by
%%     creating, for each word, a pair containing twice this word.}
%%   \hline
%% \end{fnsection}
%%
%%
%% \begin{fnsection}{Algorithms for ``realtime'' transducers}
%% \item{realtime}{t1-rw}{Compute the realtime transducer of  \var{t1-rw}.}
%% \item{is-realtime}{t1-rw}{Test if \var{t1-rw} is realtime.}
%% \item{to-tdc}{t1-rw}{Compute the equivalent fmp transducer of \var{t1-rw}.}
%% \hline
%% \end{fnsection}

\newpage
\section{\Z-Automata}
\label{sec:vcsn-z}

This part shows the use of the program \Index{\command{vcsn-z}}, but
all comments should also stand for the programs
\command{vcsn-z-min-plus} and \command{vcsn-z-max-plus}.

Again, we will toy with some of the automata provided by
\command{vcsn-z}, see \autoref{sec:auto:z}.

\subsection{Counting \samp{b}s}

\begin{figure}[tp] \centering
  \begin{VCPicture}{(0,-2)(3,2)}
    % states
    \State{(0,0)}{A}
    \State{(3,0)}{B}
    % initial--final
    \Initial{A} \Final{B}
    % transitions
    \EdgeL{A}{B}{b}
    \LoopS[.5]{A}{b}
    \LoopN[.5]{A}{a}
    \LoopS[.5]{B}{b}
    \LoopN[.5]{B}{a}
  \end{VCPicture}
  \begin{legend}
    Considered without weight, $\Bc_1$ accepts words with a
    \samp{b}.  With weights, it counts the number of \samp{b}s.  Taken
    from \citet[Fig. III.2.2, p.
    434]{sakarovitch.03.eta}.\index{B1@$\Bc_1$}
  \end{legend}
  \caption{The automaton $\Bc_1$}
  \label{fig:b1}
\end{figure}

Let's consider $\Bc_1$ (\autoref{fig:b1}), an
\index{N-automaton@$\mathbb{N}$-automaton}$\mathbb{N}$-automaton,
\textit{i.e.}  an automaton whose label's weights are in $\mathbb{N}$.
This time the evaluation of the word \var{w} by the automaton
$\Bc_1$ will produce a number, rather than simply accept or
reject \var{w}.  For instance let's evaluate \samp{abab} and
\samp{bbab}:

\execcaption{b1.abbb}{vcsn-z dump-automaton b1 | vcsn-z eval - 'abbb'}
\execcaption{b1.abab}{vcsn-z dump-automaton b1 | vcsn-z eval - 'abab'}

\noindent
Indeed, $\Bc_1$ counts the number of \samp{b}s.

\subsubsection{Power}

Now let's consider the $\Bc_1^n$, where
\begin{displaymath}
  \Bc_1^n = \prod_{i=1}^n \Bc_1, n > 0
\end{displaymath}

\noindent
This is implemented by the \Index{\taffn{power}} function:

\execcaption{b4}{vcsn-z dump-automaton b1 | vcsn-z power - 4 >b4.xml}
\begin{shell}
# vcsn-z power b1.xml 4 > b4.xml
\end{shell}

\noindent
The file \file{b4.xml} now contains the automaton $\Bc_1^4$.  Let's
check that the evaluation of the words \samp{abab} and \samp{bbab} by
$\Bc_1^4$ gives the fourth power of their evaluation by $\Bc_1$:

\execcaption{b4.abbb}{vcsn-z eval b4.xml 'abbb'}
\execcaption{b4.abab}{vcsn-z eval b4.xml 'abab'}

\subsubsection{Quotient}

Successive products of an automaton create a lot of new states and
transitions.

\execcaption{b1.info}{vcsn-z dump-automaton b1 | vcsn-z info -}
\execcaption{b4.info}{vcsn-z info b4.xml}

One way of reducing the size of our automaton is to use the
\Index{\taffn{quotient}} algorithm.

\execcaption{b4.quot.info}{vcsn-z quotient b4.xml | vcsn-z info -}


\subsection{Available functions}

In this section you will find a brief definition of all functions for
manipulating weighted automata. The following functions are available
for both.  They are called using \command{vcsn-z},
\command{vcsn-z-max-plus}, and \command{vcsn-z-min-plus} run as
\samp{\var{program} \var{algorithm-name} [\var{arguments}]}.

\execcaption{vcsn-z-commands}{vcsn-z --list-commands}

%% \smallskip
%%
%% In the following:
%%
%% \begin{itemize}
%% \item \var{a1} and \var{a2} are two weighted automata described in
%%   \Vauc XML format;
%% \item \var{w} is a word, for example \samp{aabb} if you are working on
%%   an alphabet that contains the letters \samp{a} and \samp{b};
%% \item \var{exp} is a rational expression denoting a language;
%% \item \var{n} is a non-negative integer.
%% \end{itemize}
%%
%%
%% \begin{fnsection}{Input/output work with weighted automata}
%% \item{define-automaton}{}{Define an automaton from scratch.}
%% \item{edit-automaton}{a1}{Edit an existing automaton.}
%% \item{info}{a1}{Print the number of states, transitions, initial and
%%     final states of \var{a1}.}
%% \item{display}{a1}{Display the automaton using DOTTY.}  \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Tests and evaluation on weighted automata}
%% \item{are-isomorphic}{a1 a2}{Test if the two automata are isomorphic.}
%% \item{evaluation}{a1 w}{Compute the evaluation of \var{w} by
%%     \var{a1}.}
%% \item{is-empty}{a1}{.}  \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Generic algorithms for automata}
%% \item{accessible}{a1}{Extract the sub-automaton of accessible states
%%     of \var{a1}.}
%% \item{co-accessible}{a1}{Extract the sub-automaton of co-accessible
%%     states of \var{a1}.}
%% \item{trim}{a1}{Trim the automaton \var{a1}.}
%% \item{transpose}{a1}{Compute the automaton accepting the mirror
%%     language of the one accepted by \var{a1}.}
%% \item{closure}{[-bf] a1}{$\varepsilon$-removal algorithm.}
%%   & \option{-b} : backward closure\\
%%   & \option{-f} : forward closure\\
%% \item{concatenate}{a1 a2}{Concatenate \var{a1} to \var{a2}.}
%% \item{sum}{a1 a2}{Compute the sum of \var{a1} and \var{a2}.}
%% %\item{normalize}{a1}{Compute an automaton with unique initial and
%% %    final states, with $\varepsilon$-transitions.}
%% %\item{standardize}{a1}{Compute an automaton with unique initial state
%% %    without adding $\varepsilon$-transitions.}  \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Generic algorithms for automata on letters}
%% \item{realtime}{[-bf] a1}{$\varepsilon$-removal algorithm and make
%%     every transition labeled by a letter.}
%%   & \option{-b} : backward closure\\
%%   & \option{-f} : forward closure\\
%% \item{product}{a1 a2}{Compute the (Cartesian) product of \var{a1} and
%%     \var{a1}.}
%% \item{power}{a1 n}{Compute the (Cartesian) product of \var{a1} by
%%     itself \var{n} times.}
%% \item{quotient}{a1}{Compute the $\mathbb{Z}$-quotient of \var{a1}.}
%%   \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Conversion between automata and expressions}
%% \item{aut-to-exp}{a1}{.}%%FIXME
%% \item{expand}{exp}{Partially expand rational expressions.}
%% \item{derived-term}{exp}{Compute the derived term automaton of
%%     \var{exp}.}
%% \item{standard}{exp}{Compute the standard (Glushkov) automaton of
%%     \var{exp}.}
%% \item{thompson-of}{exp}{Compute the Thompson automaton of \var{exp}.}
%%   \hline
%% \end{fnsection}


% \section{Building your own automaton}
%%FIXME: Here we should give the usage of define_automaton function.

%%% Local Variables:
%%% mode: latex
%%% ispell-local-dictionary: "american"
%%% TeX-master: "vaucanson-user-manual"
%%% End:

% LocalWords:  determinize vcsn semiring rw tdc TAF aut dmi determinizes bz xml
% LocalWords:  det detmin eval abab bbba aabb determinized Hopcroft aab fmp
% LocalWords:  Glushkov thompson realtime bbab abbb
