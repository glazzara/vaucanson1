% These two commands are recognized by extex which will extract the
% code to run to produce the generated files.  LaTeX will later
% include them.
%
% If you know a simpler means to do that, be my guest...
%
% Note that this system "caches" the result, and uses a Makefile to
% avoid useless recompilation of snippets that did not change.
\newcommand{\includegenerateddot}[1]{\includegraphics[scale=.6]{#1}}
\newcommand{\execcaption}[2]{\input{#1}}

\chapter{The \Vauc toolkit}

This chapter prevents a simple interface to \Vauc: a set of programs
tailored to be used from a traditional shell.  Since they exchange
\emph{typed} XML files, there is one program per automaton type.  Each
program support a set of operations which depends on the type of the
automaton.

Six programs are planned to be shipped in a forthcoming version:
\begin{description}
\item[vcsn-b] automata over the Boolean semiring $\mathbb{B}$;
\item[vcsn-z] automata over $(\mathbb{Z},+)$;
\item[vcsn-z-min-plus] automata over $(\mathbb{Z},min)$;
\item[vcsn-z-max-plus] automata over $(\mathbb{Z},max)$;
\item[vcsn-rt-tdc] realtime transducers;
\item[vcsn-tdc] automata over free monoid products.
\end{description}

Currently, only \command{vcsn-b}, \command{vcsn-z}, and
\command{vcsn-tdc}, are implemented.

\newpage

\section{Boolean automata}

This section focuses on the program \Index{\command{vcsn-b}}, the
TAF-Kit component dedicated to Boolean automata.  To know the list of
existing verbs:

\execcaption{vcsn-b-commands}{vcsn-b --list-commands}

In the following, some of these commands are detailed.

\subsection{A first example}

\Vauc provides a set of common automata.  The function
\Index{\taffn{list-automata}} lists them all:

\execcaption{b-list}{vcsn-b list-automata}

\begin{figure}[ht] \centering
  \begin{VCPicture}{(0,-2)(6,2)}
    % states
    \State{(0,0)}{A} \State{(3,0)}{B} \State{(6,0)}{C}
    % initial--final
    \Initial{A} \Final{C}
    % transitions
    \EdgeL{A}{B}{a} \EdgeL{B}{C}{b}
    \LoopS[.5]{A}{b} \LoopN[.5]{A}{a} \LoopS[.5]{C}{b} \LoopN[.5]{C}{a}
    %
  \end{VCPicture}
  \begin{legend}
    The graphical layout of this automaton was described by hand,
    using the Vaucanson-G \LaTeX{} package.  However, the following
    figures are generated by TAF-Kit, giving a very nice layout, yet
    slightly less artistic.
  \end{legend}
  \caption{The automaton \Index{$A_1$}}
  \label{A_1}
\end{figure}

Let's consider the Boolean automaton $A_1$ (\autoref{A_1}).  It is
part of the standard library, and can be dumped using
\Index{\taffn{dump-automaton}}:

\execcaption{a1-dump}{vcsn-b dump-automaton a1}

Usual shell indirections (\samp{|}, \samp{>}, and \samp{<}) can be
used to combine TAF-Kit commands.  For instance, this is an easy means
to bring a local copy of this file:

\execcaption{a1-xml}{vcsn-b dump-automaton a1 >a1.xml}

TAF-Kit uses XML to exchange automata, to get graphical rendering of
the automaton, you may either invoke \Index{\taffn{dot-dump}} and then
use a Dot compliant program, or use \Index{\taffn{display}} that does
both.

\execcaption{a1-dot}{vcsn-b dot-dump a1.xml >a1.dot}
\begin{center}
  \includegenerateddot{a1}
\end{center}


\subsubsection{Determinization of $A_1$}
To determinize a Boolean automaton, call the
\Index{\taffn{determinize}} function:

\execcaption{a1det}{vcsn-b dump-automaton a1 | vcsn-b determinize - >a1det.xml}

To get information about an automaton, call the \Index{\taffn{info}} function:
\execcaption{a1det-info}{vcsn-b info a1det.xml}

Or use dotty to visualize it:
\execcaption{a1det.dot}{vcsn-b dot-dump a1det.xml >a1det.dot}
\begin{center}
  \includegenerateddot{a1det}
\end{center}

\subsubsection{Minimizing}

The \index{\taffn{minimize}}minimal automaton can be computed the same way:
\begin{shell}
# vcsn_b minimize a1_det.xml > a1_min.xml
\end{shell}

The commands can be composed with pipes from the shell, using
\Index{\samp{-}} to denote the standard input.
\begin{shell}
# vcsn_b determinize a1.xml | vcsn_b minimize - > a1_min.xml
\end{shell}


\subsubsection{Evaluation}

To \index{\taffn{eval}}evaluate whether a word is accepted:

\execcaption{a1.abab}{vcsn-b eval a1.xml 'abab'}
\execcaption{a1.bbba}{vcsn-b eval a1.xml 'bbba'}

where 1 (resp. 0) means that the word is accepted (resp. not accepted)
by the automaton.

\subsection{Rational expressions and Boolean automata}

\Vauc provides functions to manipulate rational expressions associated
to Boolean automata. For instance, computing the language recognized
by a Boolean automaton can be done using \Index{\taffn{aut\_to\_exp}}:

\execcaption{a1.rat}{vcsn-b aut-to-exp a1.xml}
\execcaption{a1det.rat}{vcsn-b aut-to-exp a1det.xml}

\Vauc provides several algorithms that build an automaton that
recognizes a given language.  The following sequence computes the
minimal automaton of \samp{(a+b)*ab(a+b)*}.

\execcaption{l1}{vcsn-b --alphabet=ab standard "(a+b)*a.b.(a+b)*" | vcsn-b minimize - >l1.xml}
\execcaption{l1.dot}{vcsn-b dot-dump l1.xml >l1.dot}
\begin{center}
  \includegenerateddot{l1}
\end{center}

\subsection{Available functions}
%% Une definition plus rigoureuse des algorithmes devrait etre fournie
%% en annexe.
This section gives a brief definition of all functions that \Vauc
provides for manipulating Boolean automata.  All these algorithms are
invoked using \samp{vcsn-b \var{algorithm-name} [\var{arguments}]}. If
the argument is replaced by \samp{-} then the program will read an
argument from the standard input.  All algorithms dump their result to
the standard output, except the ``tests'' functions that also return
an exit status (0 if the test is successful, anything else otherwise).

\smallskip

In the following:
\begin{itemize}
\item \var{a1} and \var{a2} are two Boolean automata described
  in \Vauc XML format;
\item \var{w} is a word, for example \samp{"aabb"} if you are
  working on an alphabet that contains the letters \samp{a} and
  \samp{b};
\item \var{exp} is a rational expression denoting a language;
\item \var{n} is a nonnegative integer.
\end{itemize}


% \begin{fnsection}{NAME}
% -----------------------
% A group of taf-kit functions.
% Putting the ending hline in the end section is tempting, but fails.
\newenvironment{fnsection}[1]{%
  % \item{NAME}{ARGS}{DOC}
  % ----------------------
  % Define a taf-kit function.
  % We use \item because it has Emacs indentation support.
  \renewcommand{\item}[3]{\texttt{##1} \var{##2} & ##3\\}

  \tabularx{\textwidth}{|l|X|}%
    \hline\multicolumn{2}{|c|}{#1} \\\hline%
  }{%
  \endtabularx%
}


\begin{fnsection}{Input/output work with automata}
\item{define-automaton}{}{Define an automaton from scratch.}
\item{edit-automaton}{a1}{Edit an existing automaton.}
\item{info}{a1}{Print the number of states, transitions, initial and
    final states of \var{a1}.}
\item{display}{a1}{Display the automaton using Dotty.}
\item{dump}{a1}{Dump the automaton to Dot format.}  \hline
\end{fnsection}

\begin{fnsection}{Tests and evaluation on automata}
\item{are-isomorphic}{a1 a2}{Test whether \var{a1} and \var{a2} are
    isomorphic.}
\item{evaluation}{a1 w}{Test whether the word \var{w} is accepted by
    \var{a1}.}
\item{is-deterministic}{a1}{Test whether \var{a1} is deterministic.}
\item{is-empty}{a1}{Test whether \var{a1} accepts no word.}  \hline
\end{fnsection}

\begin{fnsection}{Generic algorithms for automata}
\item{accessible}{a1}{Extract the sub-automaton of accessible states
    of \var{a1}.}
\item{co-accessible}{a1}{Extract the sub-automaton of co-accessible
    states of \var{a1}.}
\item{trim}{a1}{Trim the automaton \var{a1}.}
\item{transpose}{a1}{Compute the automaton accepting the mirror
    language of the one accepted by \var{a1}.}

\item{closure}{[-bf] a1}{$\varepsilon$-removal algorithm.}
  & \option{-b} : backward closure\\
  & \option{-f} : forward closure\\
\item{concatenate}{a1 a2}{Concatenate \var{a1} to \var{a2}.}
\item{sum}{aut1 aut2}{Compute the sum of \var{a1} and \var{a2}.}
\item{normalize}{aut1}{Compute an automaton with unique initial and
    final states, with $\varepsilon$-transitions.}
\item{standardize}{aut1}{Compute an automaton with unique initial
    state without adding $\varepsilon$-transitions.}  \hline
\end{fnsection}

\begin{fnsection}{Generic algorithms for automata on letters}
\item{realtime}{[-bf] a1}{$\varepsilon$-removal algorithm and make
    every transition labeled by a letter.}
  & \option{-b} : backward closure\\
  & \option{-f} : forward closure\\
\item{product}{a1 a2}{Compute the (Cartesian) product of \var{a1} and
    \var{a2}.}
\item{power}{a1 n}{Compute the (Cartesian) product of \var{a1} by
    itself \var{n} times.}
\item{quotient}{a1}{Compute the minimal automaton in bi-simulation
    with \var{a1}.}  \hline
\end{fnsection}

\begin{fnsection}{Algorithms specific to Boolean automata}
\item{determinize}{a1}{Compute the determinized automaton of
    \var{a1}.}
\item{complement}{a1}{Compute an automaton that accepts the complement
    language of the one accepted by \var{a1}.}
\item{minimize}{[-hm] a1}{Minimize the {\em deterministic} automaton
    \var{a1}.}
  & \option{-h} : use the Hopcroft algorithm\\
  & \option{-m} : use the Moore algorithm\\
  \hline
\end{fnsection}

\begin{fnsection}{Conversion between automata and expressions}
\item{aut-to-exp}{a1}{Print a rational expression denoting the
    language accepted by \var{a1}.}
\item{expand}{exp}{Partially expand rational expressions. For
    instance, expanding \samp{a(b+ab(a+b))} will produce
    \samp{aab.(a+b)*+ab}}
\item{derived-term}{exp}{Compute the derived term automaton of
    \var{exp}.}
\item{standard}{exp}{Compute the standard (Glushkov) automaton of
    \var{exp}.}
\item{thompson-of}{exp}{Compute the Thompson automaton of \var{exp}.}
  \hline
\end{fnsection}


\newpage
\section{Transducers}

\Vauc supports two views of transducers, and therefore provides two
programs:
\begin{description}
\item[vcsn-tdc] considering a transducer as a weighted automaton of a
  product of free monoid,
\item[vcsn-rt-tdc] considering a transducer as a machine that takes a
  word as input and produce another word as (two-tape automata).
\end{description}
Both views are equivalent and \Vauc provides algorithms to pass from a
view to the other one.

\subsection{Example}

The realtime transducer $T_1$ (\autoref{bindiv3}) gives the quotient
by 3 of a binary number and the transducer $T_2$ (\autoref{add1}) adds
1 to a binary number.


\begin{figure}[h]
  \begin{center}
    \begin{VCPicture}{(0,-2)(6,2)}
      % states
      \State{(0,0)}{A} \State{(3,0)}{B} \State{(6,0)}{C}
      \Initial[w]{A}
      \Final[s]{A}
      % transitions
      \LoopN[.5]{A}{\IOL{0}{0}}
      \LoopN[.5]{C}{\IOL{1}{1}}
      \ArcL{A}{B}{\IOL{1}{0}}
      \ArcL{B}{A}{\IOL{1}{1}}
      \ArcL{B}{C}{\IOL{0}{0}}
      \ArcL{C}{B}{\IOL{0}{1}}
    \end{VCPicture}
    \caption{Realtime transducer $T_1$ computing the quotient by 3 of a binary number}
    \label{bindiv3}
  \end{center}
\end{figure}

\begin{figure}[h]
  \begin{center}
    \begin{VCPicture}{(0,-2)(3,2)}
      % states
      \State{(0,0)}{A} \State{(3,0)}{B}
      \Initial[w]{A}
      \FinalL{s}{A}{(,1)}
      \Final[e]{B}
      % transitions
      \LoopN[.5]{A}{(1,0)}
      \LoopN[.5]{B}{(1,1)}
      \LoopS[.5]{B}{(0,0)}
      \EdgeL{A}{B}{(0,1)}
    \end{VCPicture}
    \caption{Transducer $T_2$ adding 1 to a binary number}
    \label{add1}
  \end{center}
\end{figure}

\subsubsection{Evaluation}

\begin{shell}
# vcsn-rt-tdc evaluation quot_3_rt.xml '110'
\textit{0.1.0}
\end{shell}

\subsubsection{Domain}
The transducer $T$ only accepts binary number which are divisible by 3
as input.
\begin{shell}
# vcsn-rt-tdc domain quot_3_rt.xml > divisible_by_3.xml
\end{shell}
Now the file \file{divisible\_by\_3.xml} contains the description of a
Boolean automaton that accepts only the numbers divisible by 3.

\subsubsection{to-tdc}
Each transucers can be transformed to the other type of transducer
thanks to the \taffn{to-tdc} and \taffn{to-rt-tdc} functions.
\begin{shell}
# vcsn-rt-tdc to-tdc quot_3_rt.xml > quot_3.xml
# vcsn-tdc to-rt-tdc add1.xml > add1_rt.xml
\end{shell}

\subsubsection{Composing}
\begin{shell}
# vcsn-tdc compose quot_3.xml add1.xml
\end{shell}

\subsection{Available functions}
The following functions are available for both \command{vcsn-rt\_tdc}
and \command{vcsn-tdc} programs.  To invoke them, run
\samp{\var{program} \var{algorithm-name} [\var{arguments}]}.

\smallskip

In the following:

\begin{itemize}
\item \var{t1} and \var{t2} are two transducers (either ``realtime''
  or not) described in \Vauc XML format;
\item \var{w} is a word, for example \samp{"aabb"} if you are working
  on an alphabet that contains the letters \samp{a} and \samp{b};
\item \var{a} is a Boolean automaton;
\item \var{t1\_rt} is a realtime transducer;
\item \var{t1\_fmp} is a transducer (seen as an automaton over a free
  monoid product).
\end{itemize}

\begin{fnsection}{Input/output work with transducers}
\item{define-automaton}{}{Define a transducer from scratch.}
\item{edit-automaton}{t1}{Edit an existing transducer.}
\item{info}{t1}{Print the number of states, transitions, initial and
    final states of \var{t1}.}
\item{display}{t1}{Display the transducer using DOTTY.}  \hline
\end{fnsection}

\begin{fnsection}{Tests and evaluation on tranducers}
\item{are-isomorphic}{t1 t2}{Test if the two transducers are
    isomorphic.}
\item{evaluation}{t1 w}{Compute the evaluation of \var{w} by
    \var{t1}.}
\item{is-empty}{t1}{Test if \var{t1} realizes the empty relation.}
  \hline
\end{fnsection}

\begin{fnsection}{Generic algorithm for tranducers}
\item{closure}{t1}{$\varepsilon$-removal algorithm.}

\item{compose}{t1 t2}{Compute a tranducer realizing $f_2 \circ f_1$,
    where $f_1$ (resp. $f_2$) is the function associated to \var{t1}
    (resp. \var{t2}).}

\item{domain}{t1}{Compute an automaton accepting all input accepted by
    the transducer t1.}

\item{evaluation}{t1}{Compute the evaluation of w by t1.}

\item{evaluation\_aut}{t1}{Compute a Boolean automaton describing the
    words produced by the language described by a evaluated by t1.}

\item{image}{t1}{Compute an automaton describing all output produced
    by the transducer t1.}

\item{transpose}{t1}{Compute the transposed of the transducer t1.}

\item{trim}{t1}{Compute the trimmed transducer of t1.}  \hline
\end{fnsection}

\begin{fnsection}{Algorithms for transducers}
\item{sub-normalize}{t1\_fmp}{Compute the sub-nomalized transducer of
    \var{t1\_fmp}.}
\item{is-sub-normalize}{t1\_fmp}{Test if \var{t1\_fmp} is
    sub-normalized.}
\item{composition-cover}{t1\_fmp}{.}%%FIXME
\item{composition-co-cover}{t1\_fmp}{.}%%FIXME
\item{b-compose}{t1\_fmp t2\_fmp}{Compose \var{t1\_fmp} and
    \var{t2\_fmp}, two unweighted normalized or sub-normalized
    transducers.}
\item{to-rt-tdc}{t1\_fmp}{Compute the equivalent realtime transducer
    of \var{t1\_fmp}.}
\item{intersection}{a}{Transform \var{a} in a fmp transducer by
    creating, for each word, a pair containing twice this word.}
  \hline
\end{fnsection}


\begin{fnsection}{Algorithms for ``realtime'' transducers}
\item{realtime}{t1\_rt}{Compute the realtime transducer of  \var{t1\_rt}.}
\item{is-realtime}{t1\_rt}{Test if \var{t1\_rt} is realtime.}
\item{to-tdc}{t1\_rt}{Compute the equivalent fmp transducer of \var{t1\_rt}.}
\hline
\end{fnsection}

\newpage
\section{Weighted automata}

This part shows the use of the program \Index{\command{vcsn-z}}, but
all comments should also stand for the programs
\command{vcsn-z\_min\_plus} and \command{vcsn-z\_max\_plus}.

\subsection{Example}

Let's consider the following $\mathbb{N}$-automaton, \textit{i.e.}
an automaton which label's weights are in $\mathbb{N}$:

%%Schema de l'automate B1
\begin{figure}[ht] \centering
  \begin{VCPicture}{(0,-2)(3,2)}
    % states
    \State{(0,0)}{A} \State{(3,0)}{B}
    % initial--final
    \Initial{A} \Final{B}
    % transitions
    \EdgeL{A}{B}{b}
    \LoopS[.5]{A}{b} \LoopN[.5]{A}{a}
    \LoopS[.5]{B}{b} \LoopN[.5]{B}{a}
    %
  \end{VCPicture}
  \caption{The automaton \Index{$B_1$}}
\end{figure}

This time the evaluation of the word \var{w} by the automaton $B_1$
will produce a number, rather than simply accept or reject \var{w}.
For instance let's evaluate \samp{abab} and \samp{bbab}:

\subsubsection{Evaluation}

\begin{shell}
# vcsn-z eval b1.xml 'abbb'
\textit{3}
# vcsn-z eval b1.xml 'abab'
\textit{2}
\end{shell}

The automaton $B_1$ ``counts'' the number of \samp{b} contained in
\var{w}.

\subsubsection{Power}

Now let's consider the $B_1^n$, where
\begin{displaymath}
  B_1^n = \prod_{i=1}^n B_1, n > 0
\end{displaymath}

\begin{shell}
# vcsn-z power b1.xml 4 > b1_4.xml
\end{shell}

Now the file \file{b1\_4.xml} contains the automaton $B_1^4$. Lets see
what the evaluation of the words \samp{abab} and \samp{bbab} gives
with this automaton:

\begin{shell}
# vcsn-z eval b1_4.xml 'bbab'
\textit{81}
# vcsn-z eval b1_4.xml 'abab'
\textit{16}
\end{shell}

This time one can notice that the automaton $B_1^4$ returns the
evaluation of $B_1$ at power 4.

\subsubsection{Quotient}

One drawback of doing successive products of an automaton is
that it creates a lot of new states and transitions.
\begin{shell}
# vcsn-z power b1.xml 4 | vcsn-z info -
\textit{States: 16}
\textit{Transitions: 97}
\textit{Initial states: 1}
\textit{Final states: 1}
\end{shell}
One way of reducing the size of our automaton is to use the
``quotient'' algorithm.
\begin{shell}
# vcsn-z power b1.xml 4 | vcsn-z quotient - | vcsn-z info -
\textit{States: 5}
\textit{Transitions: 15}
\textit{Initial states: 1}
\textit{Final states: 1}
\end{shell}

\subsection{Available functions}
In this section you will find a brief definition of all functions for
manipulating weighted automata. The following functions are available
for both.  They are called using \command{vcsn-z},
\command{vcsn-z\_max\_plus}, and \command{vcsn-z\_min\_plus} run as
\samp{\var{program} \var{algorithm-name} [\var{arguments}]}.

\smallskip

In the following:

\begin{itemize}
\item \var{a1} and \var{a2} are two weighted automata described in
  \Vauc XML format;
\item \var{w} is a word, for example \samp{aabb} if you are working on
  an alphabet that contains the letters \samp{a} and \samp{b};
\item \var{exp} is a rational expression denoting a language;
\item \var{n} is a nonnegative integer.
\end{itemize}


\begin{fnsection}{Input/output work with weighted automata}
\item{define-automaton}{}{Define an automaton from scratch.}
\item{edit-automaton}{a1}{Edit an existing automaton.}
\item{info}{a1}{Print the number of states, transitions, initial and
    final states of \var{a1}.}
\item{display}{a1}{Display the automaton using DOTTY.}  \hline
\end{fnsection}

\begin{fnsection}{Tests and evaluation on weighted automata}
\item{are-isomorphic}{a1 a2}{Test if the two automata are isomorphic.}
\item{evaluation}{a1 w}{Compute the evaluation of \var{w} by
    \var{a1}.}
\item{is-empty}{a1}{.}  \hline
\end{fnsection}

\begin{fnsection}{Generic algorithms for automata}
\item{accessible}{a1}{Extract the sub-automaton of accessible states
    of \var{a1}.}
\item{co-accessible}{a1}{Extract the sub-automaton of co-accessible
    states of \var{a1}.}
\item{trim}{a1}{Trim the automaton \var{a1}.}
\item{transpose}{a1}{Compute the automaton accepting the mirror
    language of the one accepted by \var{a1}.}
\item{closure}{[-bf] a1}{$\varepsilon$-removal algorithm.}
  & \option{-b} : backward closure\\
  & \option{-f} : forward closure\\
\item{concatenate}{a1 a2}{Concatenate \var{a1} to \var{a2}.}
\item{sum}{a1 a2}{Compute the sum of \var{a1} and \var{a2}.}
\item{normalize}{a1}{Compute an automaton with unique initial and
    final states, with $\varepsilon$-transitions.}
\item{standardize}{a1}{Compute an automaton with unique initial state
    without adding $\varepsilon$-transitions.}  \hline
\end{fnsection}

\begin{fnsection}{Generic algorithms for automata on letters}
\item{realtime}{[-bf] a1}{$\varepsilon$-removal algorithm and make
    every transition labeled by a letter.}
  & \option{-b} : backward closure\\
  & \option{-f} : forward closure\\
\item{product}{a1 a2}{Compute the (Cartesian) product of \var{a1} and
    \var{a1}.}
\item{power}{a1 n}{Compute the (Cartesian) product of \var{a1} by
    itself \var{n} times.}
\item{quotient}{a1}{Compute the $\mathbb{Z}$-quotient of \var{a1}.}
  \hline
\end{fnsection}

\begin{fnsection}{Conversion between automata and expressions}
\item{aut-to-exp}{a1}{.}%%FIXME
\item{expand}{exp}{Partially expand rational expressions.}
\item{derived-term}{exp}{Compute the derived term automaton of
    \var{exp}.}
\item{standard}{exp}{Compute the standard (Glushkov) automaton of
    \var{exp}.}
\item{thompson-of}{exp}{Compute the Thompson automaton of \var{exp}.}
  \hline
\end{fnsection}


\section{Building your own automaton}
%%FIXME: Here we should give the usage of define_automaton function.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "vaucanson-user-manual"
%%% End:

% LocalWords:  determinize
