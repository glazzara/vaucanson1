\chapter{The \Vauc toolkit}

This chapter prevents a simple interface to \Vauc: a set of programs
tailored to be used from a traditional shell.  Since they exchange
\emph{typed} XML files, there is one program per automaton type.  Each
program support a set of operations which depends on the type of the
automaton.

Six programs are planned to be shipped in a forthcoming version:
\begin{description}
\item [vcsn-b] automata over the Boolean semiring $\mathbb{B}$;
\item [vcsn-z] automata over $(\mathbb{Z},+)$;
\item [vcsn-z-min-plus] automata over $(\mathbb{Z},min)$;
\item [vcsn-z-max-plus] automata over $(\mathbb{Z},max)$;
\item [vcsn-rt-tdc] realtime transducers;
\item [vcsn-tdc] automata over free monoid products.
\end{description}

Currently, only \command{vcsn-b}, \command{vcsn-z}, and
\command{vcsn-tdc}, are implemented.

All automata used in this chapter can be found in the
\textbf{doc/manual/examples/} directory.

\newpage

\section{Boolean automata}

This section focuses on the program \command{vcsn-b}.

\subsection{A first example}

Let's consider the following Boolean automaton \autoref{A_1}.
%%Schema de l'automate A1
\begin{figure}[ht] \centering
  \begin{VCPicture}{(0,-2)(6,2)}
    % states
    \State{(0,0)}{A} \State{(3,0)}{B} \State{(6,0)}{C}
    % initial--final
    \Initial{A} \Final{C}
    % transitions
    \EdgeL{A}{B}{a} \EdgeL{B}{C}{b}
    \LoopS[.5]{A}{b} \LoopN[.5]{A}{a} \LoopS[.5]{C}{b} \LoopN[.5]{C}{a}
    %
  \end{VCPicture}
  \caption{The automaton $A_1$}
  \label{A_1}
\end{figure}
We will use \Vauc to compute the determinized automaton of $A_1$ and
then minimize the resulting automaton.

\subsubsection{Determinization of $A_1$}
To determinize a Boolean automaton, call the \taffn{determinize}
function:
\begin{shell}
# vcsn-b determinize a1.xml > a1\_det.xml
\end{shell}
Now the file \file{a1\_det.xml} contains the XML description of the
determinized of the automaton A.

\subsubsection{Visualizing}

To get some information about the newly created automaton, call the
\taffn{info} function:
\begin{shell}
# vcsn-b info a1\_det.xml
\textit{States: 4
Transitions: 8
Initial states: 1
Final states: 2}
\end{shell}
Or use dotty to visualize our newly created automaton:
\begin{shell}
# vcsn-b display a1\_det.xml
\end{shell}

%%Dotty output of det(A1)
%%\begin{figure}[ht]
\begin{center}
  \scalebox{0.7}{\includegraphics{images/a1_det.ps}}
\end{center}
%%  \caption{Determinized of $A_1$}
%%\end{figure}

\subsubsection{Minimizing}

The minimal automaton can be computed the same way:
\begin{shell}
# vcsn_b minimize a1_det.xml > a1_min.xml
\end{shell}
The commands can be composed with pipes from the shell, using \samp{-}
to denote the standard input.
\begin{shell}
# vcsn_b determinize a1.xml | vcsn_b minimize - > a1_min.xml
\end{shell}


\subsubsection{Evaluation}

To evaluate whether a word is accepted:
\begin{shell}
# vcsn-b eval a1.xml 'abab'
\textit{1}
# vcsn-b eval a1.xml 'bbba'
\textit{0}
\end{shell}
where 1 (resp. 0) means that the word is accepted (resp. not accepted)
by the automaton.

\subsection{Rational expressions and Boolean automata}

\Vauc provides functions to manipulate rational expressions associated
to Boolean automata. For instance, computing the language recognized
by a Boolean automaton can be done using \taffn{aut\_to\_exp}:
\begin{shell}
# vcsn-b aut-to-exp a1.xml
\textit{(a+b)*.a.b.(a+b)*}
# vcsn-b aut-to-exp a1_det.xml
\textit{b*.a.a*.b.(a.a*.b+b)*.(a.a*+1)}
\end{shell}

\Vauc provides several algorithms that build an automaton that
recognizes a given language:
\begin{shell}
# vcsn-b standard "(a+b)*a.b.(a+b)*" | vcsn-b minimize -
\end{shell}
computes the minimal automaton of \samp{(a+b)*ab(a+b)*}.
%%Please note that your rational expressions should follow the
%%following grammar.
%%Fixme : Lien vers la grammaire des ratexp

\subsection{Available functions}
%% Une definition plus rigoureuse des algorithmes devrait etre fournie
%% en annexe.
This section gives a brief definition of all functions that \Vauc
provides for manipulating Boolean automata.  All these algorithms are
invoked using \samp{vcsn-b \var{algorithm-name} [\var{arguments}]}. If
the argument is replaced by \samp{-} then the program will read an
argument from the standard input.  All algorithms dump their result to
the standard output, except the ``tests'' functions that also return
an exit status (0 if the test is successful, anything else otherwise).

\smallskip

In the following:
\begin{itemize}
\item \var{a1} and \var{a2} are two Boolean automata described
  in \Vauc XML format;
\item \var{w} is a word, for example \samp{"aabb"} if you are
  working on an alphabet that contains the letters \samp{a} and
  \samp{b};
\item \var{exp} is a rational expression denoting a language;
\item \var{n} is a nonnegative integer.
\end{itemize}

\noindent
\newcommand{\fn}[3]{\texttt{#1} \var{#2} & #3\\}
\newcommand{\fnsection}[1]{\hline\multicolumn{2}{|c|}{#1} \\\hline}
\begin{tabularx}{\textwidth}{|l|X|}
\fnsection{Input/output work with automata}
\fn{define-automaton}{}{Define an automaton from scratch.}
\fn{edit-automaton}{a1}{Edit an existing automaton.}
\fn{info}{a1}{Print the number of states, transitions, initial and
  final states of \var{a1}.}
\fn{display}{a1}{Display the automaton using DOTTY.}
\fn{dump}{a1}{Dump the automaton to DOT format.}

\fnsection{Tests and evaluation on automata}
\fn{are-isomorphic}{a1 a2}{Test whether \var{a1} and \var{a2}
  are isomorphic.}
\fn{evaluation}{a1 w}{Test whether the word \var{w} is accepted by
  \var{a1}.}
\fn{is-deterministic}{a1}{Test whether
\var{a1} is deterministic.}
\fn{is-empty}{a1}{Test whether \var{a1}
accepts no word.}
\hline
\end{tabularx}
\newpage
\begin{tabularx}{\textwidth}{|l|X|}
\fnsection{Generic algorithms for automata}
\fn{accessible}{a1}{Extract the sub-automaton of accessible
            states of  \var{a1}.}
\fn{co-accessible}{a1}{Extract the sub-automaton of
co-accessible states of  \var{a1}.}
\fn{trim}{a1}{Trim the automaton  \var{a1}.}
\fn{transpose}{a1}{Compute the automaton accepting the mirror
           language of the one accepted by  \var{a1}.}

\fn{closure}{[-bf] a1}{$\varepsilon$-removal algorithm.}
                           & \option{-b} : backward closure\\
                           & \option{-f} : forward closure\\
\fn{concatenate}{a1 a2}{Concatenate  \var{a1}
            to \var{a2}.}
\fn{sum}{aut1 aut2}{Compute the sum of  \var{a1}
            and \var{a2}.}
\fn{normalize}{aut1}{Compute an automaton with unique initial
            and final states, with $\varepsilon$-transitions.}
\fn{standardize}{aut1}{Compute an automaton with unique initial
            state without adding $\varepsilon$-transitions.}

\fnsection{Generic algorithms for automata on letters}
\fn{realtime}{[-bf] a1}{$\varepsilon$-removal
algorithm and make every transition labeled by a letter.}
                           & \option{-b} : backward closure\\
                           & \option{-f} : forward closure\\
\fn{product}{a1 a2}{Compute the (Cartesian) product
           of  \var{a1} and \var{a2}.}
\fn{power}{a1 n}{Compute the (Cartesian) product of \var{a1} by itself
  \var{n} times.}
\fn{quotient}{a1}{Compute the minimal automaton in bi-simulation with
  \var{a1}.}

\fnsection{Algorithms specific to Boolean automata}
\fn{determinize}{a1}{Compute the determinized automaton
            of  \var{a1}.}
\fn{complement}{a1}{Compute an automaton that accepts
the complement language of the one accepted by  \var{a1}.}
\fn{minimize}{[-hm] a1}{Minimize the {\em deterministic}
           automaton  \var{a1}.}
                           & \option{-h} : use the Hopcroft algorithm\\
                           & \option{-m} : use the Moore algorithm\\

\fnsection{Conversion between automata and expressions}
\fn{aut-to-exp}{a1}{Print a rational expression denoting the
            language accepted by  \var{a1}.}
\fn{expand}{exp}{Partially expand rational expressions. For instance,
  expanding \samp{a(b+ab(a+b))} will produce \samp{aab.(a+b)*+ab}}
\fn{derived-term}{exp}{Compute the derived term automaton
           of \var{exp}.}
\fn{standard}{exp}{Compute the standard (Glushkov) automaton
           of \var{exp}.}
\fn{thompson-of}{exp}{Compute the Thompson automaton
           of \var{exp}.}
\hline
\end{tabularx}


\newpage
\section{Transducers}

In \Vauc we distinguish two types of transducers, and therefore
provides two programs:
\begin{description}
\item[tdc] considering a transducer as a weighted automaton of a
  product of free monoid,
\item[rt\_tdc] considering a transducer as a machine that takes a word
  as input and produce another word as.
\end{description}
Both views are equivalent and \Vauc provides algorithms to pass from a
view to the other one.

\subsection{Example}

The realtime transducer $T_1$ (\autoref{bindiv3}) gives the quotient
by 3 of a binary number and the transducer $T_2$ (\autoref{add1}) adds
1 to a binary number.


\begin{figure}[h]
  \begin{center}
    \begin{VCPicture}{(0,-2)(6,2)}
% states
\State{(0,0)}{A} \State{(3,0)}{B} \State{(6,0)}{C}
\Initial[w]{A}
\Final[s]{A}
%transitions
\LoopN[.5]{A}{\IOL{0}{0}}
\LoopN[.5]{C}{\IOL{1}{1}}
\ArcL{A}{B}{\IOL{1}{0}}
\ArcL{B}{A}{\IOL{1}{1}}
\ArcL{B}{C}{\IOL{0}{0}}
\ArcL{C}{B}{\IOL{0}{1}}
\end{VCPicture}
\caption{Realtime transducer $T_1$ computing the quotient by 3 of a binary number}
\label{bindiv3}
  \end{center}
\end{figure}
\begin{figure}[h]
  \begin{center}
    \begin{VCPicture}{(0,-2)(3,2)}
% states
\State{(0,0)}{A} \State{(3,0)}{B}
\Initial[w]{A}
\FinalL{s}{A}{(,1)}
\Final[e]{B}
%transitions
\LoopN[.5]{A}{(1,0)}
\LoopN[.5]{B}{(1,1)}
\LoopS[.5]{B}{(0,0)}
\EdgeL{A}{B}{(0,1)}
\end{VCPicture}
\caption{Transducer $T_2$ adding 1 to a binary number}
\label{add1}
  \end{center}
\end{figure}

\subsubsection{Evaluation}
\begin{shell}
# vcsn-rt-tdc evaluation quot_3_rt.xml '110'
\textit{0.1.0}
\end{shell}

\subsubsection{Domain}
The transducer $T$ only accepts binary number which are divisible by 3
as input.
\begin{shell}
# vcsn-rt-tdc domain quot_3_rt.xml > divisible_by_3.xml
\end{shell}
Now the file \file{divisible\_by\_3.xml} contains the description of a
Boolean automaton that accepts only the numbers divisible by 3.

\subsubsection{to-tdc}
Each transucers can be transformed to the other type of transducer
thanks to the \taffn{to-tdc} and \taffn{to-rt-tdc} functions.
\begin{shell}
# vcsn-rt-tdc to-tdc quot_3_rt.xml > quot_3.xml
# vcsn-tdc to-rt-tdc add1.xml > add1_rt.xml
\end{shell}

\subsubsection{Composing}
\begin{shell}
# vcsn-tdc compose quot_3.xml add1.xml
\end{shell}

\subsection{Available functions}
The following functions are available for both \command{vcsn-rt\_tdc}
and \command{vcsn-tdc} programs.  To invoke them, run
\samp{\var{program} \var{algorithm-name} [\var{arguments}]}.

\smallskip

In the following:

\begin{itemize}
\item \var{t1} and \var{t2} are two transducers (either
  ``realtime'' or not) described in \Vauc XML format;
\item \var{w} is a word, for example \samp{"aabb"} if you are
  working on an alphabet that contains the letters \samp{a} and
  \samp{b};
\item \var{a} is a Boolean automaton;
\item \var{t1\_rt} is a realtime transducer;
\item \var{t1\_fmp} is a transducer (seen as an automaton over a
  free monoid product).
\end{itemize}

\noindent
\begin{tabularx}{\textwidth}{|l|X|}
\fnsection{Input/output work with transducers}
\fn{define-automaton}{}{Define a transducer from scratch.}
\fn{edit-automaton}{t1}{Edit an existing transducer.}
\fn{info}{t1}{Print the number of states, transitions,
initial and final states of \var{t1}.}
\fn{display}{t1}{Display the transducer using DOTTY.}

\fnsection{Tests and evaluation on tranducers}
\fn{are-isomorphic}{t1 t2}{Test if the two transducers are isomorphic.}
\fn{evaluation}{t1 w}{Compute the evaluation of \var{w} by \var{t1}.}
\fn{is-empty}{t1}{Test if \var{t1} realizes the empty relation.}

\fnsection{Generic algorithm for tranducers}
\fn{closure}{t1}{$\varepsilon$-removal algorithm.}

\fn{compose}{t1 t2}{Compute a tranducer realizing $f_2 \circ f_1$,
  where $f_1$ (resp. $f_2$) is the function associated to \var{t1}
  (resp. \var{t2}).}

\fn{domain}{t1}{Compute an automaton accepting all input accepted by
  the transducer t1.}

\fn{evaluation}{t1}{Compute the evaluation of w by t1.}

\fn{evaluation\_aut}{t1}{Compute a Boolean automaton describing the
  words produced by the language described by a evaluated by t1.}

\fn{image}{t1}{Compute an automaton describing all output produced by
  the transducer t1.}

\fn{transpose}{t1}{Compute the transposed of the transducer t1.}

\fn{trim}{t1}{Compute the trimmed transducer of t1.}

\fnsection{Algorithms for transducers}
\fn{sub-normalize}{t1\_fmp}{Compute the sub-nomalized transducer of \var{t1\_fmp}.}
\fn{is-sub-normalize}{t1\_fmp}{Test if \var{t1\_fmp} is sub-normalized.}
\fn{composition-cover}{t1\_fmp}{.}%%FIXME
\fn{composition-co-cover}{t1\_fmp}{.}%%FIXME
\fn{b-compose}{t1\_fmp t2\_fmp}{Compose \var{t1\_fmp} and
  \var{t2\_fmp}, two unweighted normalized or sub-normalized
  transducers.}
\fn{to-rt-tdc}{t1\_fmp}{Compute the equivalent
realtime transducer of \var{t1\_fmp}.}
\fn{intersection}{a}{Transform \var{a} in a
fmp transducer by creating, for each word, a pair containing twice
this word.}
\hline
\end{tabularx}
\newpage

\noindent
\begin{tabularx}{\textwidth}{|l|X|}
\fnsection{Algorithms for ``realtime'' transducers}
\fn{realtime}{t1\_rt}{Compute the realtime transducer of  \var{t1\_rt}.}
\fn{is-realtime}{t1\_rt}{Test if \var{t1\_rt} is realtime.}
\fn{to-tdc}{t1\_rt}{Compute the equivalent fmp transducer of \var{t1\_rt}.}
\hline
\end{tabularx}
\newpage

\section{Weighted automata}

This part shows the use of the program \command{vcsn-z}, but all
comments should also stand for the programs
\command{vcsn-z\_min\_plus} and \command{vcsn-z\_max\_plus}.

\subsection{Example}

Let's consider the following $\mathbb{N}$-automaton, \textit{i.e.}
an automaton which label's weights are in $\mathbb{N}$:

%%Schema de l'automate B1
\begin{figure}[ht] \centering
  \begin{VCPicture}{(0,-2)(3,2)}
    % states
    \State{(0,0)}{A} \State{(3,0)}{B}
    % initial--final
    \Initial{A} \Final{B}
    % transitions
    \EdgeL{A}{B}{b}
    \LoopS[.5]{A}{b} \LoopN[.5]{A}{a}
    \LoopS[.5]{B}{b} \LoopN[.5]{B}{a}
    %
  \end{VCPicture}
  \caption{The automaton $B_1$}
\end{figure}

This time the evaluation of the word \var{w} by the automaton $B_1$
will produce a number, rather than simply accept or reject \var{w}.
For instance let's evaluate \samp{abab} and \samp{bbab}:

\subsubsection{Evaluation}

\begin{shell}
# vcsn-z eval b1.xml 'abbb'
\textit{3}
# vcsn-z eval b1.xml 'abab'
\textit{2}
\end{shell}

The automaton $B_1$ ``counts'' the number of \samp{b} contained in
\var{w}.

\subsubsection{Power}

Now let's consider the $B_1^n$, where
$$B_1^n = \prod_{i=1}^n B_1, n > 0$$

\begin{shell}
# vcsn-z power b1.xml 4 > b1_4.xml
\end{shell}

Now the file \file{b1\_4.xml} contains the automaton $B_1^4$. Lets see
what the evaluation of the words \samp{abab} and \samp{bbab} gives
with this automaton:

\begin{shell}
# vcsn-z eval b1_4.xml 'bbab'
\textit{81}
# vcsn-z eval b1_4.xml 'abab'
\textit{16}
\end{shell}

This time one can notice that the automaton $B_1^4$ returns the
evaluation of $B_1$ at power 4.

\subsubsection{Quotient}

One drawback of doing successive products of an automaton is
that it creates a lot of new states and transitions.
\begin{shell}
# vcsn-z power b1.xml 4 | vcsn-z info -
\textit{States: 16}
\textit{Transitions: 97}
\textit{Initial states: 1}
\textit{Final states: 1}
\end{shell}
One way of reducing the size of our automaton is to use the
``quotient'' algorithm.
\begin{shell}
# vcsn-z power b1.xml 4 | vcsn-z quotient - | vcsn-z info -
\textit{States: 5}
\textit{Transitions: 15}
\textit{Initial states: 1}
\textit{Final states: 1}
\end{shell}

\subsection{Available functions}
In this section you will find a brief definition of all functions for
manipulating weighted automata. The following functions are available
for both.  They are called using \command{vcsn-z},
\command{vcsn-z\_max\_plus}, and \command{vcsn-z\_min\_plus} run as
  \samp{\var{program} \var{algorithm-name} [\var{arguments}]}.

\smallskip

In the following:

\begin{itemize}
\item \var{a1} and \var{a2} are two weighted automata
  described in \Vauc XML format;
\item \var{w} is a word, for example \samp{aabb} if you are working on
  an alphabet that contains the letters \samp{a} and \samp{b};
\item \var{exp} is a rational expression denoting a language;
\item \var{n} is a nonnegative integer.
\end{itemize}
\newpage

\noindent
\begin{tabularx}{\textwidth}{|l|X|}
\fnsection{Input/output work with weighted automata}
\fn{define-automaton}{}{Define an automaton from scratch.}
\fn{edit-automaton}{a1}{Edit an existing automaton.}
\fn{info}{a1}{Print the number of states, transitions,
initial and final states of \var{a1}.}
\fn{display}{a1}{Display the automaton using DOTTY.}

\fnsection{Tests and evaluation on weighted automata}
\fn{are-isomorphic}{a1 a2}{Test if
the two automata are isomorphic.}
\fn{evaluation}{a1 w}{Compute the evaluation of
\var{w} by \var{a1}.}
\fn{is-empty}{a1}{.}
\hline

\fnsection{Generic algorithms for automata}
\fn{accessible}{a1}{Extract the sub-automaton of
accessible states of \var{a1}.}
\fn{co-accessible}{a1}{Extract the sub-automaton of
co-accessible states of \var{a1}.}
\fn{trim}{a1}{Trim the automaton \var{a1}.}
\fn{transpose}{a1}{Compute the automaton accepting the
mirror language of the one accepted by \var{a1}.}
\fn{closure}{[-bf] a1}{$\varepsilon$-removal algorithm.}
                           & \option{-b} : backward closure\\
                           & \option{-f} : forward closure\\
\fn{concatenate}{a1 a2}{Concatenate \var{a1}
to \var{a2}.}
\fn{sum}{a1 a2}{Compute the sum of \var{a1}
and \var{a2}.}
\fn{normalize}{a1}{Compute an automaton with unique
initial and final states, with $\varepsilon$-transitions.}
\fn{standardize}{a1}{Compute an automaton with unique
initial state without adding $\varepsilon$-transitions.}

\fnsection{Generic algorithms for automata on letters}
\fn{realtime}{[-bf] a1}{$\varepsilon$-removal
algorithm and make every transition labeled by a letter.}
& \option{-b} : backward closure\\
& \option{-f} : forward closure\\
\fn{product}{a1 a2}{Compute the (Cartesian) product
of \var{a1} and \var{a1}.}
\fn{power}{a1 n}{Compute the (Cartesian) product of \var{a1} by itself
  \var{n} times.}
\fn{quotient}{a1}{Compute the $\mathbb{Z}$-quotient of
 \var{a1}.}

\fnsection{Conversion between automata and expressions}
\fn{aut-to-exp}{a1}{.}%%FIXME
\fn{expand}{exp}{Partially expand rational expressions.}
\fn{derived-term}{exp}{Compute the derived term automaton
of \var{exp}.}
\fn{standard}{exp}{Compute the standard (Glushkov)
automaton of \var{exp}.}
\fn{thompson-of}{exp}{Compute the Thompson automaton
of \var{exp}.}
\hline

\end{tabularx}
\newpage

\section{Building your own automaton}
%%FIXME: Here we should give the usage of define_automaton function.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "vaucanson-user-manual"
%%% End:
