\chapter{The \Vauc toolkit}
\label{sec:tafkit}

This chapter presents a simple interface to \Vauc: a set of programs
tailored to be used from a traditional shell.  Since they exchange
\emph{typed} XML files, there is one program per automaton type.  Each
program supports a set of operations which depends on the type of the
automaton.

Many users of automata consider only automata whose transitions are
labeled by letters taken in an alphabet, which we call, roughly
speaking, \emph{classical} automata or \emph{Boolean} automata.  The
first program of the \tafkit, \command{vcsn-char-b}, allows to compute
with classical automata and is described in \autoref{sec:vcsn-char-b}.
A variant of this program called \command{vcsn-int-b} handles Boolean
automata whose letters are integers.

\autoref{sec:vcsn-char-fmp-b} describes the program
\command{vcsn-char-fmp-b} which allows to compute with transducers, that
is, automata whose transitions are labeled by pair of words, which are
elements of a \emph{product of free monoids}, hence the name.  A
variant of this program called \command{vcsn-int-fmp-b} handles
transducers whose letters are integers.

In \autoref{sec:vcsn-char-z} we consider the programs of the \tafkit
that compute with automata over a free monoid and with multiplicity,
or \emph{weight} taken in the set of integers equipped with the usual
operations of addition and multiplication, that is, the semiring $\Z$.
A variant of this program called \command{vcsn-int-z} is specialized
to handle $\Z$-automata whose letters are integers.

% ,
% or with the operations of $\min$ and addition, or the operations of
% $\max$ and addition, that is, the semirings $\Z,\min,+$ and
% $\Z,\max,+$.  Finally, the forth section describes the program
% \command{vcsn-char-rw} which allows to compute with transducers, viewed
% as automata on a free monoid (the input monoid) with multiplicity
% taken in the semiring of finite and even rational subsets of another
% free monoid (the output monoid).

\medskip


It is planned that a forthcoming version will include also:

\begin{description}
\item[vcsn-char-zmin] for automata over a free monoid with multiplicity in
  the semiring (\Z, \min, +)

\item[vcsn-char-zmax] for automata over a free monoid with multiplicity in the
  semiring (\Z, \max, +)

\item[vcsn-char-rw] for transducers viewed as automata over a free
  monoid with multiplicity in the semiring of rational sets (or
  series) over (another) free monoid.
\end{description}

\newpage

\section{Boolean automata}
\label{sec:vcsn-char-b}

This section focuses on the program \Index{\command{vcsn-char-b}}, the
\tafkit component dedicated to Boolean automata.

\subsection{First Contacts}

\command{vcsn-char-b} and its peer components of \tafkit all share the same
simple interface:

\begin{shell}
# vcsn-char-b \var{function} \var{automaton} \var{arguments...}
\end{shell}

\noindent
The \var{function} is the name of the operation to perform on the
\var{automaton}, specified as an XML file.  Some functions, such as
\taffn{evaluation}, require additional arguments, such as the word to
evaluate.  Some others, such as \taffn{exp-to-aut} do not have an
\var{automaton} argument.

\tafkit is made to work with Unix \emph{pipes}, that is to say, chains
of commands which feed each other.  Therefore, all the functions
produce a result on the standard output, and if an \var{automaton} is
\samp{-}, then the standard input is used.

\smallskip

A typical line of commands from the \tafkit reads as follows:
\begin{shell}
# \kbd{vcsn-char-b determinize a1.xml > a1det.xml}
\end{shell}
and should be understood, or analyzed, as follows.
\begin{enumerate}
\item \command{vcsn-char-b} is the call to a \command{shell} command
  that will launch a \Vauc function.  \command{vcsn-char-b} has 2
  arguments, the first one being the \var{function} which will be
  launched, the second being the \var{automaton} that is the input
  argument of the \var{function}.

\item \taffn{determinize} is, as just said, a \Vauc function.  And as
  it can easily be guessed, \taffn{determinize} takes an
  \var{automaton} as argument, performs the subset construction on it
  and outputs the result on the standard output.

\item \file{a1.xml} is the description of an automaton --- of the
  automaton of \autoref{char-b:a1} indeed --- in an XML format that is
  understood\footnote{%
    This format is not exactly part of the \Vauc platform.  It has
    been developed for providing a means of communication between
    various programs dealing with automata.  And then it has been used
    as a communication tool between the invocations of \Vauc function
    by the \tafkit.  A lay user of the \tafkit should not need to know
    how this format is
    defined%% In 1.0, we don't use the bibliography.
    \ifthenelse{\boolean{developer}}{ but a rough description of it is
      provided at \autoref{sec:xml} of the Appendix}{}.}  by \Vauc.
  This file must exist before the line is executed.  The
  \file{data/automata} directory provides a number of XML files for
  examples of automata, a number of programs that produce the XML
  files for automata whose definition depend upon some variables and
  the \tafkit itself allows to define automata and thus to produce the
  corresponding XML files (cf. below).

\item \samp{>a1det.xml} puts the result of \taffn{determinize} into
  the file \file{a1det.xml}, that is, the XML file which describes the
  determinized automaton of $\Ac_{1}$.
\end{enumerate}

\bigskip

As a more elaborate example, consider the following command

\execcaption{a1dmi}{vcsn-char-b dump-automaton a1 | vcsn-char-b determinize - | vcsn-char-b minimize - | vcsn-char-b info -}

\noindent
It fetches the automaton \code{a1} from the automaton library,
determinizes it, minimizes the result, and finally displays
information about the resulting automaton.

Please, note the typographic conventions: user input is represented
\texttt{\# \kbd{like this}}, standard output follows \texttt{like
  this}, followed by standard error output \texttt{error: like this},
and finally, if different from 0, the exit status is represented
\texttt{=> like this}.  For instance:

\execcaption{bz-mismatch}{vcsn-char-b dump-automaton a1 | vcsn-char-b info -}

\smallskip

Other than that, the interface of the \tafkit components is usual,
including options such as \option{--version} and \option{--help}:

\execcaption{vcsn-char-b-help}{vcsn-char-b --help}

The whole list of supported commands is available via
\option{--list-commands}.

\subsection{A first example}

\Vauc provides a set of common automata.  The function
\Index{\taffn{list-automata}} lists them all:

\execcaption{b-list}{vcsn-char-b list-automata}

\begin{figure}[ht] \centering
  \begin{VCPicture}{(0,-2)(6,2)}
    % states
    \State{(0,0)}{A}
    \State{(3,0)}{B}
    \State{(6,0)}{C}
    % initial--final
    \Initial{A}
    \Final{C}
    % transitions
    \EdgeL{A}{B}{a}
    \EdgeL{B}{C}{b}
    \LoopS[.5]{A}{b}
    \LoopN[.5]{A}{a}
    \LoopS[.5]{C}{b}
    \LoopN[.5]{C}{a}
  \end{VCPicture}
  \begin{legend}
    The graphical layout of this automaton was described by hand,
    using the Vaucanson-G \LaTeX{} package.  However, the following
    figures are generated by \tafkit, giving a very nice layout, yet
    slightly less artistic.\index{A1@$\Ac_1$}
    %% In 1.0, we don't use the bibliography.
    \ifthenelse{\boolean{developer}}{

      The automaton is taken from \citet[Fig. I.1.1, p.
      58]{sakarovitch.03.eta}.}{}
  \end{legend}
  \caption{The automaton $\Ac_1$}
  \label{fig:a1}
\end{figure}

Let's consider the Boolean automaton $\Ac_1$ (\autoref{fig:a1}), part
of the standard library.  It can be dumped using
\Index{\taffn{dump-automaton}}:

\execcaption{a1-dump}{vcsn-char-b dump-automaton a1}

Usual shell indirections (\samp{|}, \samp{>}, and \samp{<}) can be
used to combine \tafkit commands.  For instance, this is an easy means
to bring a local copy of this file:

\execcaption{a1-xml}{vcsn-char-b dump-automaton a1 >a1.xml}

\tafkit uses XML to exchange automata, to get graphical rendering of
the automaton, you may either invoke \Index{\taffn{dot-dump}} and then
use a Dot compliant program, or use \Index{\taffn{display}} that does
both.

\execcaption{a1-dot}{vcsn-char-b dot-dump a1.xml >a1.dot}
\begin{center}
  \includegenerateddot{a1}
\end{center}


\subsubsection{Determinization of $\Ac_1$}
To determinize a Boolean automaton, call the
\Index{\taffn{determinize}} function:

\execcaption{a1det}{vcsn-char-b dump-automaton a1 | vcsn-char-b determinize - >a1det.xml}

To get information about an automaton, call the \Index{\taffn{info}} function:
\execcaption{a1det-info}{vcsn-char-b info a1det.xml}

Or use dotty to visualize it:
\execcaption{a1det.dot}{vcsn-char-b dot-dump a1det.xml >a1det.dot}
\begin{center}
  \includegenerateddot{a1det}
\end{center}

\subsubsection{Evaluation}

To \index{\taffn{eval}}evaluate whether a word is accepted:

\execcaption{a1.abab}{vcsn-char-b eval a1.xml 'abab'}
\execcaption{a1.bbba}{vcsn-char-b eval a1.xml 'bbba'}

\noindent
where 1 (resp. 0) means that the word is accepted (resp. not accepted)
by the automaton.

\subsection{Interactive Definition of Automata}

\tafkit provides a text interface to define automata interactively,
rather than having to deal with XML files.  Two functions are
available:
\begin{description}
\item[\taffn{define-automaton}] to build a fresh automaton from scratch,
\item[\taffn{edit-automaton}] to modify an existing automaton,
\end{description}

The interface is based on a menu of choices:
\begin{shell}
# \kbd{vcsn-char-b --alphabet=ab define-automaton all.xml}
Automaton description:
  States: (none)
  Initial states: (none)
  Final states: (none)

  Transitions: (none)

Please choose your action:
  1. Add states.
  2. Delete a state.

  3. Add a transition.
  4. Delete a transition.

  5. Set a state to be initial.
  6. Set a state not to be initial.

  7. Set a state to be final.
  8. Set a state not to be final.

  9. Display the automaton in Dotty.

  10. Exit.

Your choice [1-10]:
\end{shell}

\noindent
If you enter \kbd{1}, you will then be prompted for the number of
states to add, say \kbd{1} again.  The state \code{0} was created.  To
make it initial select \kbd{5}, and:

\begin{shell}
Your choice [1-10]: \kbd{5}
  For state: \kbd{0}
\end{shell}

Likewise to make it final, using choice \kbd{7}.  Finally, let's add a
transition:

\begin{shell}
Your choice [1-10]: \kbd{3}
  Add a transition from state: \kbd{0}
  To state: \kbd{0}
  Labeled by the expression: \kbd{a+b}
\end{shell}

\noindent
The automaton is generalized, that is to say, rational expressions are
valid labels.

On top of the interactive menu, the current definition of the
automaton is reported in a textual yet readable form:

\begin{shell}
Automaton description:
  States: 0
  Initial states: 0
  Final states: 0

  Transitions:
    1: From 0 to 0 labeled by (\withweighttt{1}{a})+(\withweighttt{1}{b})
\end{shell}

\noindent
Interestingly enough, states are numbered from 0, but transitions
numbers start at 1.  Also, not that weights are reported, although
only \code{1} is valid for Boolean automata.

Finally, hit \kbd{10} to save the resulting automaton in the file
\file{all.xml}.

\subsection{Rational expressions and Boolean automata}

\Vauc provides functions to manipulate rational expressions associated
to Boolean automata.  This provides an alternative means to create
automata:

\execcaption{all.xml}{vcsn-char-b --alphabet=ab exp-to-aut '(a+b)*' >all.xml}
\execcaption{all.dot}{vcsn-char-b dot-dump all.xml >all.dot}
\begin{center}
  \includegenerateddot{all}
\end{center}

\subsection{Token representations}

When dealing with rational expressions in \tafkit, one may be willing to,
for example, change the representation of the epsilon. More generally,
the rational expressions parser understand $10$ such tokens. They are:

\begin{itemize}
\item \verb-OPAR-: the opening association parenthesis.
\item \verb-CPAR-: the closing association parenthesis.
\item \verb-PLUS-: the semi-ring additive law.
\item \verb-TIMES-: the monoid concatenation law.
\item \verb-STAR-: the Kleene star.
\item \verb-ONE-: the identity of the monoid.
\item \verb-ZERO-: the zero of the semi-ring.
\item \verb-OWEIGHT-: the opening weight brace.
\item \verb-CWEIGHT-: the closing weight brace.
\item \verb-SPACE-: a whitespace character.
\end{itemize}

\noindent
Each token must be a non-empty string, with arbitrary length. Some checks
will be done by \tafkit, to ensure tokens do not collide. You can also
use the \verb-ALPHABET- token an arbitrary number of times, to append letters
to the current alphabet. The following commands:

%% FIXME: include ({1} a) in the example
\execcaption{parser.xml}{vcsn-char-b --alphabet=ab exp-to-aut '((a) + b)*' >parser.xml}
\execcaption{parser.dot}{vcsn-char-b dot-dump parser.xml >parser.dot}
\begin{center}
  \includegenerateddot{parser}
\end{center}

\noindent
, will give the same results as:
%% FIXME: include ({1} a) in the example
\execcaption{parser2.xml}{vcsn-char-b --alphabet=a --parser="ALPHABET=b ONE=e STAR=star" exp-to-aut '(a + b)star' >parser2.xml}
\execcaption{parser2.dot}{vcsn-char-b dot-dump parser2.xml >parser2.dot}
\begin{center}
  \includegenerateddot{parser2}
\end{center}

\noindent
With the \verb-ALPHABET- token, you can specify two types of letters:

\begin{itemize}
\item letters: one character is used to represent a letter.
\item words: many characters are used to represent a letter.
\end{itemize}

For example, \verb-ALPHABET=letters:abc- defines the alphabet with three letters
$\{\verb-a-, \verb-b-, \verb-c-\}$, while \verb-ALPHABET=words:abc- defines the
alphabet with only one letter $\{\verb-abc-\}$. Letters are separated by commas, and
each \tafkit context defaults to either letters (vcsn-char-b eg) or words
(vcsn-int-b eg). \verb|vcsn-int-b --alphabet=0,1,2,3,4,5,6,7,8,9| and
\verb|vcsn-int-b --alphabet=letters:0123456789'| will give the same alphabets.

Everywhere you want to use special characters used by the \verb|--parser|
option, prepending a backslash character will escape it. So, you can write:
\verb|ALPHABET=\,,\=| which defines the alphabet with the two letters \verb-,-
and \verb-=-.

Finally whenever you may put a single character you may write a pair a words.
The following construction is then valid: \verb|ALPHABET=(\,,\))|, and defines
the alphabet with only one letter: the pair whose first component is \verb-,-
and the second one is \verb-)-.

For more details, the grammar of the \verb|--parser| option is included in the
source code in EBNF notations.

\subsubsection{Minimizing}

This automaton, constructed following the Thompson algorithm, is not
the simplest one: it can be \index{minimize@\taffn{minimize}}minimized:

\execcaption{allmin.xml}{vcsn-char-b minimize all.xml >allmin.xml}
\execcaption{allmin.dot}{vcsn-char-b dot-dump allmin.xml >allmin.dot}
\begin{center}
  \includegenerateddot{allmin}
\end{center}

\bigskip

Computing the language recognized by a Boolean automaton can be done
using \Index{\taffn{aut-to-exp}}:

\execcaption{all.rat}{vcsn-char-b aut-to-exp all.xml}
\execcaption{allmin.rat}{vcsn-char-b aut-to-exp allmin.xml}

\Vauc provides several algorithms that build an automaton that
recognizes a given language.  The following sequence computes the
minimal automaton of \samp{(a+b)*ab(a+b)*}.

\execcaption{l1}{vcsn-char-b --alphabet=ab standard "(a+b)*a.b.(a+b)*" | vcsn-char-b quotient - >l1.xml}
\execcaption{l1.dot}{vcsn-char-b dot-dump l1.xml >l1.dot}
\begin{center}
  \includegenerateddot{l1}
\end{center}

\subsection{Available functions}

The whole list of supported commands is available via
\option{--list-commands}:

\execcaption{vcsn-char-b-commands}{vcsn-char-b --list-commands}


%% Une definition plus rigoureuse des algorithmes devrait etre fournie
%% en annexe.
%% This section gives a brief definition of all functions that \Vauc
%% provides for manipulating Boolean automata.  All these algorithms are
%% invoked using \samp{vcsn-char-b \var{algorithm-name} [\var{arguments}]}. If
%% the argument is replaced by \samp{-} then the program will read an
%% argument from the standard input.  All algorithms dump their result to
%% the standard output, except the ``tests'' functions that also return
%% an exit status (0 if the test is successful, anything else otherwise).
%%
%% In the following:
%% \begin{itemize}
%% \item \var{a1} and \var{a2} are two Boolean automata described
%%   in \Vauc XML format;
%% \item \var{w} is a word, for example \samp{"aabb"} if you are
%%   working on an alphabet that contains the letters \samp{a} and
%%   \samp{b};
%% \item \var{exp} is a rational expression denoting a language;
%% \item \var{n} is a non-negative integer.
%% \end{itemize}
%%
%%
%% \begin{fnsection}{Input/output work with automata}
%% \item{define-automaton}{}{Define an automaton from scratch.}
%% \item{edit-automaton}{a1}{Edit an existing automaton.}
%% \item{info}{a1}{Print the number of states, transitions, initial and
%%     final states of \var{a1}.}
%% \item{display}{a1}{Display the automaton using Dotty.}
%% \item{dump}{a1}{Dump the automaton to Dot format.}  \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Tests and evaluation on automata}
%% \item{are-isomorphic}{a1 a2}{Test whether \var{a1} and \var{a2} are
%%     isomorphic.}
%% \item{evaluation}{a1 w}{Test whether the word \var{w} is accepted by
%%     \var{a1}.}
%% \item{is-deterministic}{a1}{Test whether \var{a1} is deterministic.}
%% \item{is-empty}{a1}{Test whether \var{a1} accepts no word.}  \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Generic algorithms for automata}
%% \item{accessible}{a1}{Extract the sub-automaton of accessible states
%%     of \var{a1}.}
%% \item{co-accessible}{a1}{Extract the sub-automaton of co-accessible
%%     states of \var{a1}.}
%% \item{trim}{a1}{Trim the automaton \var{a1}.}
%% \item{transpose}{a1}{Compute the automaton accepting the mirror
%%     language of the one accepted by \var{a1}.}
%%
%% \item{closure}{[-bf] a1}{$\varepsilon$-removal algorithm.}
%%   & \option{-b} : backward closure\\
%%   & \option{-f} : forward closure\\
%% \item{concatenate}{a1 a2}{Concatenate \var{a1} to \var{a2}.}
%% \item{sum}{aut1 aut2}{Compute the sum of \var{a1} and \var{a2}.}
%% %\item{normalize}{aut1}{Compute an automaton with unique initial and
%% %    final states, with $\varepsilon$-transitions.}
%% %\item{standardize}{aut1}{Compute an automaton with unique initial
%% %    state without adding $\varepsilon$-transitions.}  \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Generic algorithms for automata on letters}
%% \item{rational-weight}{[-bf] a1}{$\varepsilon$-removal algorithm and make
%%     every transition labeled by a letter.}
%%   & \option{-b} : backward closure\\
%%   & \option{-f} : forward closure\\
%% \item{product}{a1 a2}{Compute the (Cartesian) product of \var{a1} and
%%     \var{a2}.}
%% \item{power}{a1 n}{Compute the (Cartesian) product of \var{a1} by
%%     itself \var{n} times.}
%% \item{quotient}{a1}{Compute the minimal automaton in bi-simulation
%%     with \var{a1}.}  \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Algorithms specific to Boolean automata}
%% \item{determinize}{a1}{Compute the determinized automaton of
%%     \var{a1}.}
%% \item{complement}{a1}{Compute an automaton that accepts the complement
%%     language of the one accepted by \var{a1}.}
%% \item{minimize}{[-hm] a1}{Minimize the {\em deterministic} automaton
%%     \var{a1}.}
%%   & \option{-h} : use the Hopcroft algorithm\\
%%   & \option{-m} : use the Moore algorithm\\
%%   \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Conversion between automata and expressions}
%% \item{aut-to-exp}{a1}{Print a rational expression denoting the
%%     language accepted by \var{a1}.}
%% \item{expand}{exp}{Partially expand rational expressions. For
%%     instance, expanding \samp{a(b+ab(a+b))} will produce
%%     \samp{aab.(a+b)*+ab}}
%% \item{derived-term}{exp}{Compute the derived term automaton of
%%     \var{exp}.}
%% \item{standard}{exp}{Compute the standard (Glushkov) automaton of
%%     \var{exp}.}
%% \item{thompson-of}{exp}{Compute the Thompson automaton of \var{exp}.}
%%   \hline
%% \end{fnsection}
%%

\newpage
\section{Transducers}
\label{sec:vcsn-char-fmp-b}

While the \Vauc library supports two views of transducers, currently
\tafkit only provides one view:

\begin{description}
\item[vcsn-char-fmp-b] considering a transducer as a weighted automaton of a
  product of free monoid,
\end{description}

In a forthcoming release, \tafkit will provide:

\begin{description}
\item[vcsn-char-rw] considering a transducer as a machine that takes a
  word as input and produce another word as (two-tape automata).
\end{description}

Both views are equivalent and \Vauc provides algorithms to pass from a
view to the other one.

\subsection{Example}

\begin{figure}[tp]
  \begin{center}
    \begin{VCPicture}{(0,-2)(6,2)}
      % states
      \State{(0,0)}{A} \State{(3,0)}{B} \State{(6,0)}{C}
      \Initial[w]{A}
      \Final[s]{A}
      % transitions
      \LoopN[.5]{A}{\IOL{0}{0}}
      \LoopN[.5]{C}{\IOL{1}{1}}
      \ArcL{A}{B}{\IOL{1}{0}}
      \ArcL{B}{A}{\IOL{1}{1}}
      \ArcL{B}{C}{\IOL{0}{0}}
      \ArcL{C}{B}{\IOL{0}{1}}
    \end{VCPicture}
    \begin{legend}
      The transducer computing the quotient by 3 of a binary number.
    \end{legend}
    \caption{Rational-weight transducer $\Tc_1$}
    \label{fig:t1}
  \end{center}
\end{figure}

%% \begin{figure}[tp]
%%   \begin{center}
%%     \begin{VCPicture}{(0,-2)(3,2)}
%%       % states
%%       \State{(0,0)}{A} \State{(3,0)}{B}
%%       \Initial[w]{A}
%%       \FinalL{s}{A}{(,1)}
%%       \Final[e]{B}
%%       % transitions
%%       \LoopN[.5]{A}{(1,0)}
%%       \LoopN[.5]{B}{(1,1)}
%%       \LoopS[.5]{B}{(0,0)}
%%       \EdgeL{A}{B}{(0,1)}
%%     \end{VCPicture}
%%     \caption{Transducer $\Tc_2$ adding 1 to a binary number}
%%     \label{fig:t2}
%%   \end{center}
%% \end{figure}

To experiment with transducers, we will use \index{T1@$\Tc_1$}$\Tc_1$,
described in \autoref{fig:t1}, and part of the automaton library
(\autoref{char-fmp-b:t1}).

%% \subsubsection{Evaluation}
%%
%% Currently \tafkit requires the user to specify the alphabets to use
%% using \option{--alphabet1} and \option{--alphabet2}.
%%
%% \execcaption{t1.110}{vcsn-char-fmp-b --alphabet1=ab eval t1.xml 'bba'}

\subsubsection{Domain}
The transducer $T$ only accepts binary numbers divisible by 3.

\execcaption{t1.dom}{vcsn-char-fmp-b dump-automaton t1 | vcsn-char-fmp-b --alphabet1=ab domain - >div-by-3.xml}

Now the file \file{divisible-by-3.xml} contains the description of a
Boolean automaton that accepts only the numbers divisible by 3:

\execcaption{div-by-3.dot}{vcsn-char-b dot-dump div-by-3.xml >div-by-3.dot}
\includegenerateddot{div-by-3}


%% \subsubsection{to-tdc}
%% Each transducer can be transformed to the other type of transducer
%% thanks to the \taffn{to-tdc} and \taffn{to-rw-tdc} functions.
%% \begin{shell}
%% # vcsn-char-rw to-tdc quot_3_rw.xml > quot_3.xml
%% # vcsn-char-fmp-b to-rw-tdc add1.xml > add1_rw.xml
%% \end{shell}
%%
%% \subsubsection{Composing}
%% \begin{shell}
%% # vcsn-char-fmp-b compose quot_3.xml add1.xml
%% \end{shell}

\subsection{Available functions}
The following functions are available for both \command{vcsn-char-rw}
and \command{vcsn-char-fmp-b} programs.  To invoke them, run
\samp{\var{program} \var{algorithm-name} [\var{arguments}]}.

\execcaption{vcsn-char-fmp-b-commands}{vcsn-char-fmp-b --list-commands}

%% In the following:
%%
%% \begin{itemize}
%% \item \var{t1} and \var{t2} are two transducers (either ``rational-weight''
%%   or not) described in \Vauc XML format;
%% \item \var{w} is a word, for example \samp{"aabb"} if you are working
%%   on an alphabet that contains the letters \samp{a} and \samp{b};
%% \item \var{a} is a Boolean automaton;
%% \item \var{t1-rw} is a rational-weight transducer;
%% \item \var{t1-fmp} is a transducer (seen as an automaton over a free
%%   monoid product).
%% \end{itemize}
%%
%% \begin{fnsection}{Input/output work with transducers}
%% \item{define-automaton}{}{Define a transducer from scratch.}
%% \item{edit-automaton}{t1}{Edit an existing transducer.}
%% \item{info}{t1}{Print the number of states, transitions, initial and
%%     final states of \var{t1}.}
%% \item{display}{t1}{Display the transducer using DOTTY.}  \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Tests and evaluation on transducers}
%% \item{are-isomorphic}{t1 t2}{Test if the two transducers are
%%     isomorphic.}
%% \item{evaluation}{t1 w}{Compute the evaluation of \var{w} by
%%     \var{t1}.}
%% \item{is-empty}{t1}{Test if \var{t1} realizes the empty relation.}
%%   \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Generic algorithm for transducers}
%% \item{closure}{t1}{$\varepsilon$-removal algorithm.}
%%
%% \item{compose}{t1 t2}{Compute a transducer realizing $f_2 \circ f_1$,
%%     where $f_1$ (resp. $f_2$) is the function associated to \var{t1}
%%     (resp. \var{t2}).}
%%
%% \item{domain}{t1}{Compute an automaton accepting all input accepted by
%%     the transducer t1.}
%%
%% \item{evaluation}{t1}{Compute the evaluation of w by t1.}
%%
%% \item{evaluation-aut}{t1}{Compute a Boolean automaton describing the
%%     words produced by the language described by a evaluated by t1.}
%%
%% \item{image}{t1}{Compute an automaton describing all output produced
%%     by the transducer t1.}
%%
%% %\item{transpose}{t1}{Compute the transposed of the transducer t1.}
%%
%% \item{trim}{t1}{Compute the trimmed transducer of t1.}  \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Algorithms for transducers}
%% \item{sub-normalize}{t1-fmp}{Compute the sub-normalized transducer of
%%     \var{t1-fmp}.}
%% \item{is-sub-normalized}{t1-fmp}{Test if \var{t1-fmp} is
%%     sub-normalized.}
%% \item{composition-cover}{t1-fmp}{.}%%FIXME
%% \item{composition-co-cover}{t1-fmp}{.}%%FIXME
%% \item{b-compose}{t1-fmp t2-fmp}{Compose \var{t1-fmp} and
%%     \var{t2-fmp}, two unweighted normalized or sub-normalized
%%     transducers.}
%% \item{to-rw-tdc}{t1-fmp}{Compute the equivalent realtime transducer
%%     of \var{t1-fmp}.}
%% \item{intersection}{a}{Transform \var{a} in a fmp transducer by
%%     creating, for each word, a pair containing twice this word.}
%%   \hline
%% \end{fnsection}
%%
%%
%% \begin{fnsection}{Algorithms for ``realtime'' transducers}
%% \item{realtime}{t1-rw}{Compute the realtime transducer of  \var{t1-rw}.}
%% \item{is-realtime}{t1-rw}{Test if \var{t1-rw} is realtime.}
%% \item{to-tdc}{t1-rw}{Compute the equivalent fmp transducer of \var{t1-rw}.}
%% \hline
%% \end{fnsection}

\newpage
\section{\Z-Automata}
\label{sec:vcsn-char-z}

This part shows the use of the program \Index{\command{vcsn-char-z}}, but
all comments should also stand for the programs
\command{vcsn-char-z-min-plus} and \command{vcsn-char-z-max-plus}.

Again, we will toy with some of the automata provided by
\command{vcsn-char-z}, see \autoref{sec:auto:char-z}.

\subsection{Counting \samp{b}s}

\begin{figure}[tp] \centering
  \begin{VCPicture}{(0,-2)(3,2)}
    % states
    \State{(0,0)}{A}
    \State{(3,0)}{B}
    % initial--final
    \Initial{A} \Final{B}
    % transitions
    \EdgeL{A}{B}{b}
    \LoopS[.5]{A}{b}
    \LoopN[.5]{A}{a}
    \LoopS[.5]{B}{b}
    \LoopN[.5]{B}{a}
  \end{VCPicture}
  \begin{legend}
    Considered without weight, $\Bc_1$ accepts words with a \samp{b}.
    With weights, it counts the number of \samp{b}s.
    %% In 1.0, we don't use the bibliography.
    \ifthenelse{\boolean{developer}}{Taken from \citet[Fig. III.2.2,
      p.  434]{sakarovitch.03.eta}.\index{B1@$\Bc_1$}}{}
  \end{legend}
  \caption{The automaton $\Bc_1$}
  \label{fig:b1}
\end{figure}

Let's consider $\Bc_1$ (\autoref{fig:b1}), an
\index{N-automaton@$\mathbb{N}$-automaton}$\mathbb{N}$-automaton,
\textit{i.e.}  an automaton whose label's weights are in $\mathbb{N}$.
This time the evaluation of the word \var{w} by the automaton
$\Bc_1$ will produce a number, rather than simply accept or
reject \var{w}.  For instance let's evaluate \samp{abab} and
\samp{bbab}:

\execcaption{b1.abbb}{vcsn-char-z dump-automaton b1 | vcsn-char-z eval - 'abbb'}
\execcaption{b1.abab}{vcsn-char-z dump-automaton b1 | vcsn-char-z eval - 'abab'}

\noindent
Indeed, $\Bc_1$ counts the number of \samp{b}s.

\subsubsection{Power}

Now let's consider the $\Bc_1^n$, where
\begin{displaymath}
  \Bc_1^n = \prod_{i=1}^n \Bc_1, n > 0
\end{displaymath}

\noindent
This is implemented by the \Index{\taffn{power}} function:

\execcaption{b4}{vcsn-char-z dump-automaton b1 | vcsn-char-z power - 4 >b4.xml}
\begin{shell}
# vcsn-char-z power b1.xml 4 > b4.xml
\end{shell}

\noindent
The file \file{b4.xml} now contains the automaton $\Bc_1^4$.  Let's
check that the evaluation of the words \samp{abab} and \samp{bbab} by
$\Bc_1^4$ gives the fourth power of their evaluation by $\Bc_1$:

\execcaption{b4.abbb}{vcsn-char-z eval b4.xml 'abbb'}
\execcaption{b4.abab}{vcsn-char-z eval b4.xml 'abab'}

\subsubsection{Quotient}

Successive products of an automaton create a lot of new states and
transitions.

\execcaption{b1.info}{vcsn-char-z dump-automaton b1 | vcsn-char-z info -}
\execcaption{b4.info}{vcsn-char-z info b4.xml}

One way of reducing the size of our automaton is to use the
\Index{\taffn{quotient}} algorithm.

\execcaption{b4.quot.info}{vcsn-char-z quotient b4.xml | vcsn-char-z info -}


\subsection{Available functions}

In this section you will find a brief definition of all functions for
manipulating weighted automata. The following functions are available
for both.  They are called using \command{vcsn-char-z},
\command{vcsn-char-z-max-plus}, and \command{vcsn-char-z-min-plus} run as
\samp{\var{program} \var{algorithm-name} [\var{arguments}]}.

\execcaption{vcsn-char-z-commands}{vcsn-char-z --list-commands}

%% \smallskip
%%
%% In the following:
%%
%% \begin{itemize}
%% \item \var{a1} and \var{a2} are two weighted automata described in
%%   \Vauc XML format;
%% \item \var{w} is a word, for example \samp{aabb} if you are working on
%%   an alphabet that contains the letters \samp{a} and \samp{b};
%% \item \var{exp} is a rational expression denoting a language;
%% \item \var{n} is a non-negative integer.
%% \end{itemize}
%%
%%
%% \begin{fnsection}{Input/output work with weighted automata}
%% \item{define-automaton}{}{Define an automaton from scratch.}
%% \item{edit-automaton}{a1}{Edit an existing automaton.}
%% \item{info}{a1}{Print the number of states, transitions, initial and
%%     final states of \var{a1}.}
%% \item{display}{a1}{Display the automaton using DOTTY.}  \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Tests and evaluation on weighted automata}
%% \item{are-isomorphic}{a1 a2}{Test if the two automata are isomorphic.}
%% \item{evaluation}{a1 w}{Compute the evaluation of \var{w} by
%%     \var{a1}.}
%% \item{is-empty}{a1}{.}  \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Generic algorithms for automata}
%% \item{accessible}{a1}{Extract the sub-automaton of accessible states
%%     of \var{a1}.}
%% \item{co-accessible}{a1}{Extract the sub-automaton of co-accessible
%%     states of \var{a1}.}
%% \item{trim}{a1}{Trim the automaton \var{a1}.}
%% \item{transpose}{a1}{Compute the automaton accepting the mirror
%%     language of the one accepted by \var{a1}.}
%% \item{closure}{[-bf] a1}{$\varepsilon$-removal algorithm.}
%%   & \option{-b} : backward closure\\
%%   & \option{-f} : forward closure\\
%% \item{concatenate}{a1 a2}{Concatenate \var{a1} to \var{a2}.}
%% \item{sum}{a1 a2}{Compute the sum of \var{a1} and \var{a2}.}
%% %\item{normalize}{a1}{Compute an automaton with unique initial and
%% %    final states, with $\varepsilon$-transitions.}
%% %\item{standardize}{a1}{Compute an automaton with unique initial state
%% %    without adding $\varepsilon$-transitions.}  \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Generic algorithms for automata on letters}
%% \item{realtime}{[-bf] a1}{$\varepsilon$-removal algorithm and make
%%     every transition labeled by a letter.}
%%   & \option{-b} : backward closure\\
%%   & \option{-f} : forward closure\\
%% \item{product}{a1 a2}{Compute the (Cartesian) product of \var{a1} and
%%     \var{a1}.}
%% \item{power}{a1 n}{Compute the (Cartesian) product of \var{a1} by
%%     itself \var{n} times.}
%% \item{quotient}{a1}{Compute the $\mathbb{Z}$-quotient of \var{a1}.}
%%   \hline
%% \end{fnsection}
%%
%% \begin{fnsection}{Conversion between automata and expressions}
%% \item{aut-to-exp}{a1}{.}%%FIXME
%% \item{expand}{exp}{Partially expand rational expressions.}
%% \item{derived-term}{exp}{Compute the derived term automaton of
%%     \var{exp}.}
%% \item{standard}{exp}{Compute the standard (Glushkov) automaton of
%%     \var{exp}.}
%% \item{thompson-of}{exp}{Compute the Thompson automaton of \var{exp}.}
%%   \hline
%% \end{fnsection}


% \section{Building your own automaton}
%%FIXME: Here we should give the usage of define_automaton function.

%%% Local Variables:
%%% mode: latex
%%% ispell-local-dictionary: "american"
%%% TeX-master: "vaucanson-user-manual"
%%% End:

% LocalWords:  determinize vcsn semiring rw tdc TAF aut dmi determinizes bz xml
% LocalWords:  det detmin eval abab bbba aabb determinized Hopcroft aab fmp dom
% LocalWords:  Glushkov thompson realtime bbab abbb monoids zmin zmax
