<!doctype linuxdoc system>

<article>

<title>Vaucanson XML developement documentation.
<author>Valentin David, <tt>valentin@lrde.epita.fr</tt>
<date>December 2003
<abstract>
This document describe the Vaucanson XML developement.
</abstract>

<toc>

<p>
There is three way to use the Vaucanson XML interface.
<itemize>
<item>static mode
<item>dynamic mode
<item>pseudo-generic mode
</itemize>

<sect>Static mode

<p>
This mode use the standard Vaucanson I/O system. An instance of the
<tt/vcsn::xml::xml_loader/ class has to be passed to the
<tt/automaton_loader/ and <tt/automaton_saver/ functions.

<code>
#include <vaucanson/xml/static.hh>
#include <vaucanson/tools/usual.hh>
#include <iostream>

int main()
{
  using namespace vcsn;
  using namespace vcsn::tools;
  using namespace vcsn::xml;

  XML_BEGIN;
  AUTOMATON_TYPES_EXACT(usual_automaton_t);

  automaton_t a;

  std::cin >> automaton_loader(a, io::string_out(),
                               xml::xml_loader());

  /* work on a */

  std::cout << automaton_saver(a, io::string_out(),
                               xml::xml_loader());

  XML_END;
}
</code>

<sect>Dynamic mode

<p>
This mode able to choose the implementation following the type of the
automaton described in the XML Document.

<p>
The automaton is first loaded in a <tt/xml_automaton_t/ typed
variable. Then the type can be accessed.

<p>
Here is an easy to understand example :
<code>
#include <vaucanson/xml/dynamic.hh>
#include <vaucanson/tools/usual.hh>
#include <iostream>

int main()
{
  xml_automaton_t dynamic_automaton;

  std::cin >> dynamic_automaton;

 if (x.set().semiring_set() == XmlSet::B) {
    AUTOMATON_TYPES_EXACT(usual_automaton_t);
    XMLOF(automaton_t) xml_automaton = dynamic_automaton;
    automaton_t automaton = xml_automaton;

    /* work on automaton */

    xml_automaton = automaton;
    std::cout << xml_automaton;
  }

  if ((x.set().semiring_type() == XmlSet::NUMERICAL)
      && (x.set().semiring_set() == XmlSet::Z)) {
    AUTOMATON_TYPES_EXACT(weighted_automaton_t);
    XMLOF(automaton_t) xml_automaton = dynamic_automaton;
    automaton_t automaton = xml_automaton;

    /* work on automaton */

    xml_automaton = automaton;
    std::cout << xml_automaton;
  }

  return 0;
}
</code>

But this example can be written better using generic programming.

<code>
#include <vaucanson/xml/dynamic.hh>
#include <vaucanson/tools/usual.hh>
#include <iostream>

template <typename T>
int print_out(typename XMLOF(T) x)
{
  using namespace vcsn;
  using namespace vcsn::tools;
  using namespace vcsn::xml;

  AUTOMATON_TYPES_EXACT(T);

  automaton_t a = x;

  /* work on a */

  x = a;
  std::cout << x;
  return 0;
}

int main()
{
  using namespace vcsn;
  using namespace vcsn::tools;
  using namespace vcsn::xml;

  XML_BEGIN;

  xml_automaton_t x;

  std::cin >> x;

  if ((x.set().semiring_type() == XmlSet::NUMERICAL)
      && (x.set().semiring_set() == XmlSet::Z))
    return print_out<numerical_automaton_t>(x);

  if (x.set().semiring_set() == XmlSet::B)
    return print_out<usual_automaton_t>(x);

  std::cerr << "Automaton type not dealt" << std::endl;
  return -1;
}
</code>

<sect>Generic mode

<p>
The generic mode is very long to compile. So, some constants have to be set
for activating some parts.

<itemize>
<item><tt/VCSN_XML_GENRERIC_WEIGHTED/: Enable "Z" and "R" for semiring.
<item><tt/VCSN_XML_GENRERIC_TRANSDUCERS/: Enable "ratseries" for semiring (no recursion).
<item><tt/VCSN_XML_GENRERIC_CHAR_PAIRS/: Enable "pair" of letters for free monoid.
<item><tt/VCSN_XML_GENRERIC_WEIGHTED_LETTERS/: Enable "weighted" letters for free monoid.
<item><tt/VCSN_XML_GENRERIC_INT_LETTERS/: Enable "integers" for free monoid.
</itemize>

<code>
#define VCSN_XML_GENRERIC_WEIGHTED 1

#include <vaucanson/xml/generic.hh>
#include <vaucanson/tools/usual.hh>
#include <iostream>

struct MyData
{
  int argc;
  char **argv;
  MyData(int c, char** v) : argc(c), argv(v) { }
};

template <typename Auto>
struct MyCallBack
{
  int operator()(Auto& a, MyData&)
  {
    using namespace vcsn;
    using namespace vcsn::tools;
    using namespace vcsn::xml;

    AUTOMATON_TYPES(Auto);

    /* work on a */

    return 0;
  }
};

int main(int argc, char *argv[])
{
  using namespace vcsn;
  using namespace vcsn::xml;

  XML_BEGIN;

  MyData data(argc, argv);
  return apply<MyCallBack, MyData>(std::cin, data);
}
</code>

<sect>Error processing

<p>
There are two possibilities, for error processing.

<itemize>
<item>The program exit on failure.
<item>The program raise an exception on failure (default).
</itemize>

<p>
To switch this mode a macro has to be set.
<itemize>
<item><tt/#define FAIL WITH_EXIT/ for exiting.
<item><tt/#define FAIL WITH_THROW/ for raising exception.
</itemize>

When raising exceptions, the raised exception is mainly a
<tt/vcsn::xml::LoaderException/ one. This exception provides the
method <tt/get_msg()/.

<code>
  xml_automaton_t x;

  try {
    std::cin >> x;
  }
  catch (const xml::LoaderException& e) {
    std::cerr << "XML parser error: " << e.get_msg() << std::endl;
    return -1;
  }
</code>

<sect>Geometry

<sect1>Keeping

<p>
To keep the geometry in a graph implemented automaton, the type has to
be converted to accept attached data.

<code>
template <typename T>
int print_out(typename XMLOF(T) x)
{
  using namespace vcsn;
  using namespace vcsn::tools;
  using namespace vcsn::xml;

  typedef typename ATTACHXMLINFOS(T) my_automaton_t;
  AUTOMATON_TYPES(my_automaton_t);

  automaton_t a = x;

  /* then, here, a contains the geometry */

  return 0;
}
</code>

<sect1>Accessing

<p>
The data are in the <tt/Tag/. This tag is <tt/XmlInfosTag/ typed. See
Vaucanson API documentation for more information.

<code>
// This example aling states diagonnaly with a depth-first traversal.
template<typename I>
void align(I& a)
{
  AUTOMATON_TYPES(I);
  int x = 0;
  std::map<hstate_t,bool> visited;
  std::stack<hstate_t> stack;

  for_each_state(i, a) {
    visited[*i] = false;
    // ensure inaccessible states will be visited
    stack.push(*i);
  }

  for_each_initial_state(i, a)
    stack.push(*i);

  while (!stack.empty()) {
    hstate_t i = stack.top();
    stack.pop();

   if (!visited[i]) {
      visited[i] = true;

      a.tag().states[i]().x = a.tag().states[i]().y = x++;

      std::list<hedge_t> aim;
      a.deltac(aim, i, delta_kind::edges());
      for_all_const_(std::list<hedge_t>, j, aim)
        stack.push(a.aim_of(*j));
    }
  }
}
</code>

<sect>Sessions

<p>
Sessions are handled like lifo by class
<tt/xml::XmlSession/. <tt/&lt;&lt;/ and <tt/>>/ operators are use for
poping un pushing.

<code>
#include <vaucanson/xml/session.hh>
#include <vaucanson/tools/usual.hh>
#include <iostream>

int main()
{
  using namespace vcsn;
  using namespace vcsn::tools;
  using namespace vcsn::xml;

  XML_BEGIN;

  typedef XMLOF(usual_automaton_t) my_xml_automaton_t;
  AUTOMATON_TYPES_EXACT(usual_automaton_t);

  automaton_t a;
  my_xml_automaton_t x;
  xml_automaton_t dyn;

  XmlSession session1, session2;
  std::cin >> session1;
  session1 >> dyn;
  a = my_xml_automaton_t(dyn);

  /* work on a */

  session2 << my_xml_automaton_t(a);

  session >> dyn;
  a = my_xml_automaton_t(dyn);

  /* work on a */

  session2 << my_xml_automaton_t(a);

  XML_END;

  return 0;
}
</code>

</article>