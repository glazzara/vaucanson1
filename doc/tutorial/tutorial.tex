% tutorial.tex
%
% $Id$
\documentclass{article}

\include{packages}
\include{macros}
\include{definitions}

\begin{document}

\title{Vaucanson -- a tutorial}

\maketitle
\tableofcontents

\section{Overview}

\subsection{Presentation}

Vaucanson is a C++ library for finite state machine manipulation. 

Vaucanson is:

\begin{itemize}
  
\item \textbf{generic}: a general algorithm is written once and is
  instantiated for the good parameters at use ;
  
\item \textbf{algorithm oriented}: the system is meant to provide
  primitive services to write algorithms ;

\item \textbf{meta}: the C++ is enriched to obtain a flexible framework.

\end{itemize}

\subsection{Distribution, installation, basic usage}

The tarball can be found at \url{http://www.lrde.epita.fr/twiki/VaucansonLib}.

The installation is the classical:

\begin{verbatim}
./configure
make
make install (as root)
\end{verbatim}

If you are not root on your system, you can install Vaucanson by typing:

\begin{verbatim}
./configure --with-prefix=$HOME/include/ 
make
make install
\end{verbatim} % $

The only difference is that you must specify a -I \$(HOME)/include in
your compilation flags.

\subsection{Directory tree}

The Vaucanson library is organized as follows: 

\begin{verbatim}
`-- vaucanson
    |-- algebra
    |   |-- concept
    |   `-- concrete
    |       |-- alphabets
    |       |-- free_monoid
    |       |-- letter
    |       |-- semiring
    |       `-- series
    |           `-- rat
    |-- algorithms
    |-- automata
    |   |-- concept
    |   `-- concrete
    |-- config
    |-- fundamental
    |-- internal
    |-- misc
    `-- tools
\end{verbatim}

\begin{itemize}
\item \textbf{fundamental}: the core of the library, its goal is to
  enriched C++. (see section \ref{sec:fundamental}) ;

\item \textbf{config}: the internal configuration system ;
\item \textbf{internal}: the internal C++ headers ;
\item \textbf{algebra}: the algebra module ;
\item \textbf{automata}: the automata module ;
\item \textbf{algorithms}: the algorithms set ;
\item \textbf{misc}: some tools to interact with external tools ;
\item \textbf{tools}: some useful tools for daily work.
\end{itemize}

\subsection{A simple example}

% FIXME: choose a good example.

\subsection{Plan}

The goal of this document is to present the philosophy of the library
and to demonstrate some features of the system in a practical manner.

\section{Preliminaries}

%FIXME: vcsn namespace, template C++ references, articles, STL ... etc etc

\section{Fundamental: enriched c++}

The fundamental module provides some sugar to build the system
genericity. It can be seen as the core of the system and, then,
non-expert users do not have to understand it. Yet, a so-called
'Element' design pattern is used in every line of Vaucanson to enable
orthogonal specialization and genericity: one must be aware of it
before coding with the Vaucanson library.

\subsection{Element/Set design pattern}

As mentionned in (FIXME), Vaucanson is designed in an algebraic
manner. To reinforce this view and to provide a simple way to separate
implementation and theoritical behaviour, we use a unified way to
structure all the object used in the library: the Element pattern. The
'Basics' section is essential whereas the other can be skipped for a
first reading.

\subsubsection{Basics}

First, in Vaucanson, everything is an instance of
\textbf{vcsn::Element$<$S, T$>$} where the 'S' parameter is
interpreted as the set of the element and 'T' as its implementation.
For example, Element$<$Series, polynom$>$ is an element of the series
implemented with the polynom class. What is important is that every
Element$<$S, T$>$ provides the same interface. You can access the
implementation by the 'value()' method and the set by the 'set()' one.
As a consequence, objects are build incrementally from their set. 

% FIXME: Write valid Vaucanson code please !
% FIXME: add all the code into the src/demos.
\begin{code}[Use of the element services.]
Alphabet a;
FreeMonoid f(a);
Semiring s;
Series s(f, s);
Element<Series, polynom> s;
Element<FreeMonoid, std::string> m(f);
Element<Semiring, int>   w;
s.set();          // the series set.
s.set().monoid(); // the monoid.
s.value();        // the polynom.
m.set().alphabet() == s.set().monoid().alphabet();
s[m] = w;
\end{code}

Second, the particular behaviour of an implementation 'T' viewed as an
element of a set 'S' is defined by specialization of the class
\textbf{vcsn::MetaElement$<$S, T$>$}. For instance, the
MetaElement$<$Series, polynom$>$ provides a 'is\_stareable()' method
that returns true if we can take the star of the current serie. The
MetaElement class is not a user class, it is just a way to define the
interpretation of the implementation as a particular concept.

% FIXME:Add example.

% FIXME: consequence => separation in the library between concrete/concept.

\subsubsection{A short example}

\subsubsection{Inheritance between Element}

\subsubsection{Orthogonal specialization}

\subsubsection{Dynamic/Static properties}

\section{Dealing with algebraic structures}

Even if classical context are provided (like letter acceptor),
Vaucanson enables the user to precisely define the algebraic context
to work with. 

The next sections show how it can be done for the main algebraic
components: alphabet, free monoid, semiring, serie and rational
expression.

\subsection{Alphabet}

\begin{tabular}%
{ll}
\hline \\
concept: & \MyDefAlphabet  \\
concerned files: & algebra/concept/alphabets\_base.h[h, xx] \\
                 & algebra/concrete/alphabet/* \\
\hline 
\end{tabular}

\hspace{1cm}

In Vaucanson, the set of all alphabets over a particular type of
letter is denoted by the AlphabetSetBase abstract class. Consequently,
to get all the services you can expect from an alphabet, you must look
at MetaElement specialized w.r.t AlphabetSetBase (in
algebra/concept/alphabets\_base.hh)

A final class AlphabetSet implements this class in a trivial manner:
it is an empty class only for static typing purpose. This class is
just parameterized by the type of letter. So, we have to provide the
kind of letter we wish to manipulate inside our future alphabet. You
can use the C++-\textit{builtins} types (like char, int, ...)  or use
more specific types proposed in Vaucanson.

For example, let us define a type alias declaring that we want to work
with letter implemented with 'char':

\begin{code}[Letter implemented with char]
typedef char Letter;
\end{code}

Sometimes, it is useful to work only on a subset of the 'char' type,
that's why you can use the 'static\_ranged' class:

\begin{code}[Letter implemented with static\_ranged]
typedef static_ranged<char, static_char_interval<'a','z'> >  Letter;
\end{code}

If you choose this last option, symbols can only be letters between
'a' and 'z', nothing more. The set of all the alphabets that contain
this type of letter is expressed in Vaucanson with:

\begin{code}[Type denoting the set of alphabet holding letter of type 'Letter']
typedef AlphabetSet<Letter>  Alphabets;
\end{code}

An element of the alphabet set (\textit{ie} an alphabet) can be
implemented in many ways. For example, we can use std::set or
std::list for dynamic alphabets. Lastly, we can create the type of
the alphabet we will effectively use, with the Element pattern:

\begin{code}[Type of an alphabet implemented with std::set structure]
typedef Element<Alphabets, std::set<Letter> >  Alphabet;
\end{verbatim}

This previous should be understand like: ``an element of the set of
alphabets holding 'Letter' letter and implemented by a std::set of
'Letter' ''.  Actually, this code is already present inside Vaucanson, more
exactly inside the file ``algebra/concrete/alphabet/predefs.hh''.

\begin{code}{The pre-existing alphabet definitions in Vaucanson]
 namespace small_alpha_letter {
      
      typedef static_ranged<char, static_char_interval<'a','z'> >  Letter;
      typedef AlphabetSet<Letter>                                  Alphabets;
      typedef Element<Alphabets, std::set<Letter> >                Alphabet;

    } // small_alpha_letter

    namespace char_letter {

      typedef AlphabetSet<char>                            Alphabets;
      typedef Element<Alphabets, std::set<char> >                  Alphabet;

    } // char_letter

    namespace int_letter {

      typedef AlphabetSet<int>                                     Alphabets;
      typedef Element<Alphabets, std::set<int> >                   Alphabet;

    } // int_letter
\end{code}

You only have to choose the right namespace for your work, or create a new.

To finish, here is a short example of alphabet manipulation :

\begin{code}[Example of alphabet manipulation]
  using namespace vcsn;
  using namespace algebra;
  using namespace small_alpha_letter;
  
  using std::cout;
  using std::endl;
  
  Alphabet A;
  Letter a('a');

  A.insert(a);
  A.insert('b');
  
  cout << "Size of alphabet : "
       << A.size() << endl;                // return 2
    
  cout << "Is \'a\' inside alphabet ? (0 or 1) : "
       << A.contains('a') << endl;         //return true

  cout << "Is \'1\' inside alphabet ? (0 or 1) : "
       << A.contains('1') << endl;         //return false
  
  cout << "element of alphabet are : ";
  for (Alphabet::iterator i = A.begin(); i != A.end(); i++)
    cout << *i << " ";
  cout << endl;
  
  cout << "random sequence of 10 symbols of the alphabet : ";
  for (unsigned i = 0; i < 10; i++)
    cout << A.choose() << " ";
  cout << endl;
\end{code}

\subsection{Free monoid}

Now we use an algebraic structure called a free moinoid. It is the set of
words we can represent with an alphabet (a collection of symbols) and
a specific operation. 

\subsection{Semiring}

\subsection{Series}

\subsection{Rational expression}

\section{Automaton}

\subsection{Simple usage}

\section{Algorithms}

\section{Your 'grep'}

\subsection{From a regular expression to an automaton}

\subsection{Speed}

\subsection{Multiplicity in action}

\section{Play with multiplicity}

\section{Advanced use}

\subsection{Extending Vaucanson}

\subsection{Glossary}

\end{document}