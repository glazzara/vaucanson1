% tutorial.tex
%
% $Id$
\documentclass{article}

\include{packages}
\include{macros}
\include{definitions}

\begin{document}

\title{Vaucanson -- a tutorial}

\maketitle
\tableofcontents

\section{Overview}

\subsection{Presentation}

Vaucanson is a C++ library for finite state machine manipulation. 

Vaucanson is:

\begin{itemize}
  
\item \textbf{generic}: a general algorithm is written once and is
  instantiated for the good parameters at use ;
  
\item \textbf{algorithm oriented}: the system is meant to provide
  primitive services to write algorithms ;

\item \textbf{meta}: the C++ is enriched to obtain a flexible framework.

\end{itemize}

\subsection{Distribution, installation, basic usage}

The tarball can be found at \url{http://www.lrde.epita.fr/twiki/VaucansonLib}.

The installation is the classical:

\begin{verbatim}
./configure
make
make install (as root)
\end{verbatim}

If you are not root on your system, you can install Vaucanson on your
home directory by typing:

\begin{verbatim}
./configure --with-prefix=$HOME/include/ 
make
make install
\end{verbatim} % $

The only difference is that you must specify a -I \$(HOME)/include in
your compilation flags.

\subsection{Directory tree}

The Vaucanson library is organized as follows: 

\begin{verbatim}
`-- vaucanson
    |-- algebra
    |   |-- concept
    |   `-- implementation
    |       |-- alphabets
    |       |-- free_monoid
    |       |-- letter
    |       |-- semiring
    |       `-- series
    |           `-- rat
    |-- algorithms
    |-- automata
    |   |-- concept
    |   `-- implementation
    |-- config
    |-- design_pattern
    |-- internal
    |-- misc
    `-- tools
\end{verbatim}

\begin{itemize}
\item \textbf{design_pattern}: the core of the library, its goal is to
  enriched C++. (see section \ref{sec:design_pattern}) ;

\item \textbf{config}: the internal configuration system ;
\item \textbf{internal}: the internal C++ headers ;
\item \textbf{algebra}: the algebra module ;
\item \textbf{automata}: the automata module ;
\item \textbf{algorithms}: the algorithms set ;
\item \textbf{misc}: some tools to interact with external tools ;
\item \textbf{tools}: some useful tools for daily work.
\end{itemize}

\subsection{Aim of this document}

The goal of this document is to present the philosophy of the library
and to demonstrate some features of the system in a practical manner.

\subsection{A simple example}

At the end of this tutorial, you will probably be able to write a generic
algorithm that complete a finite state machine like this one:

\begin{code}[A simple example]
template <class T>
void complete(Element<Automata, T>& auto)
{
  typedef Element<Automata, T> automaton_t;
  AUTOMATON_TYPES(automaton_t);

  const alphabet_t& alphabet = auto.series().monoid().alphabet();
  std::set<hedge_t> delta_ret;
  hstate_t          hole_state = auto.add_state();

  for_each_state(s, auto)
    for_each_letter(e, alphabet)
    {
      delta_ret.clear();
      a.letter_deltac(delta_ret, *s, *e);
      if (delta_ret.size() == 0)
        auto.add_letter_edge(*s, hole_state, *e);
    }
}
\end{code}

\section{Preliminaries}

%FIXME: vcsn namespace, template C++ references, articles, STL ... etc etc

\section{Fundamental: enriched c++}

The design_pattern module provides some sugar to build the system
genericity. It can be seen as the core of the system and, then,
non-expert users do not have to understand it. Yet, a so-called
'Element' design pattern is used in every lines of Vaucanson to enable
genericity: one must be aware of it before coding with the Vaucanson
library.

\subsection{Element/Set design pattern}

Vaucanson is designed in an algebraic
manner. To reinforce this view and to provide a simple way to separate
implementation and theoritical behaviour, we use a unified way to
structure all the objects used in the library: the Element pattern. The
'Basics' section is essential whereas the other can be skipped for a
first reading.

\subsubsection{Basics}

First, in Vaucanson, everything is an instance of
\textbf{vcsn::Element$<$S, T$>$} where the 'S' parameter is
interpreted as the set of the element and 'T' as its implementation.
For example, Element$<$Series, polynom$>$ is an element of the series
implemented with the polynom class. What is important is that every
Element$<$S, T$>$ provides the same interface. You can access the
implementation by the 'value()' method and the set by the 'set()' one.
As a consequence, objects are build incrementally from their set. 

% FIXME: Write valid Vaucanson code please !
% FIXME: add all the code into the src/demos.
\begin{code}[Use of the element services.]
Alphabet a;
FreeMonoid f(a);
Semiring s;
Series s(f, s);
Element<Series, polynom<std::string, int> > s;
Element<FreeMonoid, std::string> m(f);
Element<Semiring, int>   w;
s.set();          // the series set.
s.set().monoid(); // the monoid.
s.value();        // the polynom.
m.set().alphabet() == s.set().monoid().alphabet();
s.assoc(m, w);
\end{code}

Second, the particular behaviour of an implementation 'T' viewed as an
element of a set 'S' is defined by specialization of the class
\textbf{vcsn::MetaElement$<$S, T$>$}. For instance, the
MetaElement$<$Series, polynom$>$ provides a 'is\_stareable()' method
that returns true if we can take the star of the current serie. The
MetaElement class is not a user class, it is just a way to define the
interpretation of the implementation as a particular concept. 

% FIXME:Add example.

% FIXME: consequence => separation in the library between implementation/concept.

\subsubsection{A short example}

\subsubsection{Inheritance between Element}

\subsubsection{Orthogonal specialization}

\subsubsection{Dynamic/Static properties}

\section{Dealing with algebraic structures}

Even if classical context are provided (like letter acceptors),
Vaucanson enables the user to precisely define the algebraic context
to work with. 

Next sections show how it can be done for the main algebraic
components: alphabet, free monoid, semiring, serie and rational
expression.

Thanks to the Element design pattern, these constructions are unified:
you first define the set of your element and then one (or several)
instance(s) of it.

\subsection{Alphabet}

\begin{tabular}%
{ll}
\hline 
concept: & \textbf{alphabet, letter} \\
concerned files: & algebra/concept/alphabets\_base.h[h, xx] \\
                 & algebra/implementation/alphabet/* \\
\hline 
\end{tabular}

\hspace{1cm}

In Vaucanson, the set of all alphabets over a particular type of
letter is denoted by the AlphabetSetBase abstract class. Consequently,
to get all the services you can expect from an alphabet, you must look
at MetaElement specialized w.r.t AlphabetSetBase (in
algebra/concept/alphabets\_base.hh)

A final class AlphabetSet implements this class in a trivial manner:
it is an empty class only for static typing purpose. This class is
just parameterized by the type of letters. So, we just have to provide
the kind of letter we wish to manipulate inside our future alphabet.
You can use the C++-\textit{builtins} types (like char, int, ...)  or
use more specific types proposed in Vaucanson.

For example, let us define a type alias declaring that we want to work
with letter implemented with 'char':

\begin{code}[Letter implemented with char]
typedef char Letter;
\end{code}

Sometimes, it is useful to work only on a subset of the 'char' type,
that's why you can use the 'static\_ranged' class:

\begin{code}[Letter implemented with static\_ranged]
typedef static_ranged<char, static_char_interval<'a','z'> >  Letter;
\end{code}

If you choose this last option, symbols can only be letters between
'a' and 'z', nothing more. The set of all the alphabets that contain
this type of letter is expressed in Vaucanson with:

\begin{code}[Type denoting the set of alphabet holding letter of type 'Letter']
typedef AlphabetSet<Letter>  Alphabets;
\end{code}

An element of the alphabet set (\textit{ie} an alphabet) can be
implemented in many ways. For example, we can use std::set or
std::list for dynamic alphabets. Lastly, we can create the type of
the alphabet we will effectively use, with the Element pattern:

\begin{code}[Type of an alphabet implemented with std::set structure]
typedef Element<Alphabets, std::set<Letter> >  Alphabet;
\end{code}

This previous type should be understood like: ``an element of the set
of alphabets holding 'Letter' letter and implemented by a std::set of
'Letter' ''.  Actually, this code is already present inside Vaucanson,
more exactly inside the file ``\verb!algebra/implementation/alphabet/predefs.hh!''.

\begin{code}[The pre-existing alphabet definitions in Vaucanson]
 namespace small_alpha_letter {
      
      typedef static_ranged<char, static_char_interval<'a','z'> >  Letter;
      typedef AlphabetSet<Letter>                                  Alphabets;
      typedef Element<Alphabets, std::set<Letter> >                Alphabet;

    } // small_alpha_letter

    namespace char_letter {

      typedef AlphabetSet<char>                                    Alphabets;
      typedef Element<Alphabets, std::set<char> >                  Alphabet;

    } // char_letter

    namespace int_letter {

      typedef AlphabetSet<int>                                     Alphabets;
      typedef Element<Alphabets, std::set<int> >                   Alphabet;

    } // int_letter
\end{code}

You only have to choose the right namespace for your work, or create a new.

To finish, here is a short example of alphabet manipulation :

\begin{code}[Example of alphabet manipulation]
  using namespace vcsn;
  using namespace algebra;
  using namespace small_alpha_letter;
  
  using std::cout;
  using std::endl;
  
  Alphabet A;
  Letter a('a');

  A.insert(a);
  A.insert('b');
  
  cout << "Size of alphabet : "
       << A.size() << endl;                // return 2
    
  cout << "Is \'a\' inside alphabet ? (0 or 1) : "
       << A.contains('a') << endl;         //return true

  cout << "Is \'1\' inside alphabet ? (0 or 1) : "
       << A.contains('1') << endl;         //return false
  
  cout << "element of alphabet are : ";
  for (Alphabet::iterator i = A.begin(); i != A.end(); i++)
    cout << *i << " ";
  cout << endl;
  
  cout << "random sequence of 10 symbols of the alphabet : ";
  for (unsigned i = 0; i < 10; i++)
    cout << A.choose() << " ";
  cout << endl;
\end{code}

\subsection{Free monoid}

\begin{tabular}%
{ll}
\hline 
concept: & \textbf{Free monoid}  \\
concerned files: & algebra/concept/freemonoid\_base.h[h, xx] \\
                 & algebra/implementation/freemonoid/* \\
\hline 
\end{tabular}

\hspace{1cm}

Alphabet and letter are not enough to express language manipulation,
we need the word concept. A word is a sequence of letters. 

The algebraic structure denoting the set of words is called a
\textbf{free monoid}. Such a set needs an alphabet to be
characterized. Usually, we write ``$A^{\star}$'' for the free monoid
generated by an alphabet A.

A free monoid is fully characterized by a concatenation operation,
denoted as a product '.', an empty word and an alphabet. In Vaucanson,
this concept is managed by the FreeMonoidBase abstract class. For
example, we can write such a function:

\begin{code}[A function that manipulates a Free Monoid]
template <class Self>
unsigned free_monoid_alphabet_cardinal(const FreeMonoidBase<Self>& fm)
{
  return fm.alphabet().size();
}
\end{code}

A natural definition for a concrete free monoid is the FreeMonoid
class which aggregates an instance of the alphabet:

\begin{code}[An instance of a free monoid over the alphabet $\{a, b\}$]
{
  using small_alpha_letter;
  typedef FreeMonoid<Alphabet>  Words;
  Alphabet     alphabet;
  alphabet.insert('a');
  alphabet.insert('b');
  FreeMonoid<Alphabet> free_monoid(alphabet);
  free_monoid_alphabet_cardinal(free_monoid);
}
\end{code}

A predefinition of this class exists in
\verb!algebra/implementation/free_monoid/predefs.hh!. It is called 'Words'.

Now, let's work with element of this set. Naturally, a word can be
implemented with a \verb!std::basic_string<Letter>!.

Then, its type using the Element class is:

\begin{code}[An element of a free monoid implemented with std::string]
{
  Element<Words, std::basic_string<Letter> > word;
}
\end{code}

A predefinition of this class exists in
algebra/implementation/free\_monoid/predefs.hh, it is called 'Word'.

As a sequence, a word provides iterators and reverse iterators. 

\begin{code}[Free monoid element iterators]
  Word str(free_monoid);
  str = "abb";
  for (Word::iterator i = str.begin(); i != str.end(); i++)
    cout << *i << " ";
  cout << endl;
  for (Word::reverse_iterator i = str.rbegin(); i != str.rend(); i++)
    cout << *i << " ";
  cout << endl;
\end{code}

Some others services and external functions are proposed:

\begin{code}[Free monoid element services]
  Word str(free_monoid);
  str = "abb";
  // Side effect.
  str.mirror();
  cout << str << endl;
  // Pure functional mirroring.
  cout << mirror(str) << endl;
  cout << str.length() << endl;
\end{code}

To obtain all the services of a word, please look at
``\verb!algebra/free_monoid/concept/freemonoid_base.hh!.

How to get the neutral element of the semiring (the empty word) ? It
is not the role of an element to provide it, the set is the only owner
of this information. Yet, the set is not aware of the implementation
to choose to instantiate the neutral element ! 

The solution is to precise to the set the implementation we want. To
do that, we use a tricky typed null pointer:

\begin{code}[Get the empty string]
free_monoid.identity((std::string*)(0));   // horrible but it works.
free_monoid.identity(SELECT(std::string)); // macro to hide it.
identity_as<std::string>::of(free_monoid); // solution using a template function.
\end{code}

\subsection{Semiring}

\begin{tabular}%
{ll}
\hline 
concept: & \textbf{Semiring}  \\
concerned files: & algebra/concept/semiring\_base.h[h, xx] \\
                 & algebra/implementation/semiring/* \\
\hline 
\end{tabular}

To characterize some words of the language, we usually use element
from a semiring. A semiring is a set which provides a multiplication,
an addition and neutral elements for each of these operations.
Consequently, we can compute the ``score'' of every words in function of
these primitive operations.

The unweighted finite state machines are also called ``acceptors''. In
fact, there are just weighted with boolean. Consequently, we can
instantiate the Boolean semiring:

\begin{code}[The Boolean semiring]
BooleanSemiring semiring;
\end{code}

If you look at algebra/concept/boolean\_semiring.hh, you will see that
the BooleanSemiring is an empty class. Indeed, there is no dynamic
data associated to it: it is only present for static purpose.

A straightforward implementation of a boolean weight is the builtin
``bool''. Vaucanson provides such an implementation:

\begin{code}[A boolean in action !]
Element<BooleanSemiring, bool> t = true;
Element<BooleanSemiring, bool> f = false;
std::cout << t * f << std::endl;
std::cout << t + f << std::endl;
\end{code}

As with free monoid, particular elements can be retrieved using the set:

\begin{code}[Get the identity and the zero of the semiring]
semiring.identity(SELECT(bool));
semiring.identity((bool*)(0));
zero_as<bool>::of(semiring);
\end{code}

Some other semirings are useful for weighted automaton. For example,
Vaucanson provides the famous MaxTropical semiring. An element of such
a semiring can be an integer encoded as an 'int' builtin:

\begin{code}[(Z, Max, +) tropical semiring]
MaxTropical semiring;
Element<MaxTropical, int> a = 1;
Element<MaxTropical, int> b = zero_as<int>::of(semiring);
Element<MaxTropical, int> c = identity_as<int>::of(semiring);

cout << a << endl;
cout << b << endl;
cout << c << endl;

\end{code}

A really important operation is the ``star'' of a semiring element x
that is defined by:

\begin{center}
\begin{math}
x^{\star} = \sum_{k=0}^{\infty}{x^k}
\end{math}
\end{center}
The star is useful when you want to symbolize a non bounded computing
of weight (for example, when you want to associate a weight to a star
regular expression). Yet, the star operation is not defined
everywhere.  Consequently, Vaucanson provides two services star() and
is\_stareable():

\begin{code}[The star of a semiring element]
Element<MaxTropical, int> a = 1;
Element<MaxTropical, int> b = -1;
Element<MaxTropical, int> z = zero_as<int>::of(semiring);
Element<MaxTropical, int> i = identity_as<int>::of(semiring);
cout << a.is_stareable() << std::endl;
cout << b.is_stareable() << std::endl;
cout << z.is_stareable() << std::endl;
cout << i.is_stareable() << std::endl;
cout << z.star() << std::endl;
\end{code}

\subsection{Series}

\begin{tabular}%
{ll}
\hline 
concept: & \textbf{Series}  \\
concerned files: & algebra/concept/series\_base.h[h, xx] \\
                 & algebra/implementation/series/* \\
\hline 
\end{tabular}

We want to manipulate the mapping between words and weights as object.
This kind of object is called formal series. Vaucanson enables the
construction of series element. 

The set of series is constructed from a free monoid and a semiring:

\begin{code}[The set of series]
Series<BooleanSemiring, FreeMonoid<Alphabet> > series(freemonoid, semiring); 
\end{code}

Then, we can implement a finite serie using a finite support map.
Vaucanson provides such an implementation through the polynoms class:

\begin{code}[A serie]
Element<BooleanSeries, polynom<std::string, bool> > serie(series);
\end{code}

As a map, a serie can associate a weight to a word:

\begin{code}[Serie's services]
serie.assoc(``foo'') = true;
cout << serie.get(``foo'') << endl;
cout << serie.get(``baz'') << endl;
\end{code}

The set of series can be seen as a semiring, then a serie inherits all
the services of a semiring element:

\begin{code}[A serie as a semiring]
serie.star();
Element<BooleanSeries, polynom<std::string, bool> > serie2(series);
serie2.assoc(``a'') = true;
Element<BooleanSeries, polynom<std::string, bool> > serie3(series);
serie3.assoc(``a'') = true;
cout << serie1 + serie2 << endl;
cout << serie1 + serie3 << endl;
cout << serie2 * serie1 << endl;
cout << serie1.is_stareable() << endl;
\end{code}

\subsection{Rational expression}

The polynom implementation does not manage infinite series. Indeed, we
can't denote such serie in an extensional way. Yet, a particular class
of infinite series can be expressed using a finite formalism: the
rational expressions. The Kleene theorem says that this class of
series is exactly what can be recognized by a finite state machine.

Vaucanson enables us to define such series:

\begin{code}[A rational expression]
Element<BooleanSeries, polynom<std::string, bool> > serie(series);
series = "a";
Element<BooleanSeries, polynom<std::string, bool> > serie2(series);
series2 = "ab";
Element<BooleanSeries, polynom<std::string, bool> > serie3(series);
series3 = "b";
cout << serie1 + serie2 << endl;
cout << serie1 + serie3 << endl;
cout << serie2 * serie1 << endl;
cout << serie1.is_stareable() << endl;
cout << (serie1.star() + serie2) * serie3 << endl; 
\end{code}

As syntactic expression, rational expresssion can be parsed:

\begin{code}
parse("(a+b*).ab", exp);
std::cout << exp << std::endl;
\end{code}

\section{Automaton}

FIXME: definition automate.

An automaton is both a theorical and a computational object.
Therefore, the services must be both general and atomic as possible. 

However, the underlying data structure can be more or less adapted to each of these trends. For example, a graph with letter as label is a great structure for computation but to be seen as series the label must be enriched. At the contrary, a graph with series as label will be a great theorical object but will be heavy in memory and at computation.

A basic data structure must be enough to define the primitive services but some sugar is necessary to help the user. FIXME: exemple !

Finally, automaton are big structures, they must be reference-counted.

\subsection{Instantiating an automaton}

\begin{tabular}%
{ll}
\hline \\
concept: & \textbf{Automaton}  \\
concerned files: & automata/concept/automata\_base.h[h, xx] \\
\hline 
\end{tabular}

A set of automaton is characterized by a series set. So, first, we have to define it:

\begin{code}[The set of automata]
Automata automata_set(series);
cout << automata_set.series().monoid().alphabet() << endl;
\end{code}

The implementation of an automaton is the composition of 3 three things:

\begin{itemize}
\item a kind
\item an implementation adapter
\item a reference counter
\end{itemize}

The kind is parameterized by the type of the automaton label and adapt final services consequently. The implementation adapter is responsible of sugar. The reference counter suppress unuseful copy.

\subsubsection{Structure operations}

As a graph, an automaton is composed of states and edges. Usually, handlers are used to represent nodes and edges. In fact, handlers are comparable to unsigned integer. 

The automaton is able to create and remove nodes and edges :

\begin{code}[Structural operations]
hstate_t s1 = a.add_state();
hstate_t s2 = a.add_state();
hedge_t e1 = a.add_letter_edge(s1, s2, 'a');
hedge_t e2 = a.add_letter_edge(s1, s2, 'b');
hstate_t s3 = a.add_state();
hedge_t e3 = a.add_edge(s1, s3, 'a');
hedge_t e3 = a.add_spontaneous(s1, s3);
a.del_state(s3);
a.del_edge(s3);
\end{code}

When you remove a state/edge, the other handlers are not updated.

\subsubsection{Delta function}

The delta function represents the outer transitions associated to a state. However, there are many ways of viewing this set. 

\paragraph{what kind of information to retrieve ?}

The last argument of delta is the type of the retrieve information. It can be hstate\_t or hedge\_t.

\paragraph{where to store the information ?}

Their are two kinds of return storing: you can use a standard container or an output iterator. FIXME: other kind of DELTA with two iterators !

\paragraph{what criteria to filter transition ?}

The simplest way to select transitions is to get them all. Another way is quite natural: you can specify a letter that must matches with the label. The last one is to use an object function that represents the criteria as an operator() with a label as argument.

\subsection{Standard services}

The set of states and the set of edges are provided to permit to iterate over the states and the edges. 

The initial and the final applications are modelised using mapping. 

Additional information can be attached to  the nodes or to the edges: this is what is called Tag in Vaucanson.

\subsection{Standard macros}

To help the user when writing automaton algorithms, a set of macros is provided.

\subsection{Usage example}

FIXME: fusion max !

\section{Algorithms}

\subsection{General form}

\subsection{Manipulation}

\subsection{Determinisation}

\subsection{Minimisation}

\section{Grammar inference}

MAX !

\section{Your 'grep'}

'grep' is a well known unix tools used to look for pattern in a text. The pattern is described as a rationale expression: if a substring of the line is in the language denoted by the expression, the line is print in the output.

A naive implementation of grep uses an automaton of the form:

\subsection{From a regular expression to an automaton}

There exists many algorithms to construct an automaton that recognizes the language denoted by an expression. The most popular is the Thompson's one.

\begin{code}[A naive grep]
Ok
\end{code}

\subsection{Speed consideration}

Do not be pessimistic, we can improve our naive implementation of grep.

\paragraph{What implementation ?}

\paragraph{Algorithm's refinement ...}

\subsection{Multiplicity in action}

\section{Play with multiplicity}

Imagine now that we want to determine the shortest length of the pattern that has been matched.

\section{Advanced use}

\subsection{Extending Vaucanson}

\subsection{Glossary}

\end{document}
