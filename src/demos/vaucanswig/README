Glossary
========

In this document, the name "category" designates the set of features
related to a particular algebraic configuration.

The following categories are predefined:

* usual: bool weights, string words, polynom as serie_t, exp as exp_t
* numerical: int weights, string words, polynom as serie_t, exp as exp_t
* tropical_min: int weights / tmin, string words, polynom as serie_t, exp as exp_t
* tropical_max: int weights / tmin, string words, polynom as serie_t, exp as exp_t

They are those defined in usual.hh. Adding more categories is done by
adding more typedefs to usual.hh and the corresponding loop items in
expand.sh.

What is in a category ?
=======================

For a given category D, vaucanswig defines the following modules:

* vaucanswig_D_context: algebra and algebraic context
* vaucanswig_D_automaton: automata types (standard and generalized)
* vaucanswig_D_alg_...: the algorithm wrappers
* vaucanswig_D_algorithms: a wrapper around all available algorithms

Algebra
-------

The module vaucanswig_D_context contains:

* D_alphabet_t:
      D_alphabet_t(const char*);
* D_monoid_t:
      standard vaucanson constructors and operators
      make(const std::string&);
      D_monoid_elt_t identity();
* D_weights_t:
      standard vaucanson constructors and operators
      make(int);
      D_weight_t identity();
      D_weight_t zero();
* D_series_t:
      standard vaucanson constructors and operators
      D_serie_t make(int);
      D_serie_t make(const std::string&);
      D_serie_t identity();
      D_serie_t zero();
      D_exp_t exp_identity();
      D_exp_t exp_zero();
* D_automata_set_t:
      standard vaucanson constructors and operators

* D_context:
      D_context(const automata_set_t&);
      D_context(const D_context&);
      accessors:
         automata_set(), series(), 
         monoid(), alphabet(), weights()
      shortcut constructors:
         D_weight_t(int);
         D_monoid_elt_t(const std::string&);
         D_serie_t serie(int);
         D_serie_t serie(const std::string&);
         D_exp_t exp(const D_serie_t&); 
            // expression from polynom
         D_exp_t exp(cosnt std::string&); 
            // expression parser
    
* D_context make_context(const D_alphabet_t&); 
    // shortcut context from alphabet

* D_monoid_elt_t:
* D_weight_t:
* D_serie_t:
* D_exp_t:
      standard vaucanson constructors and operators


In addition, all classes are equipped with a `describe' method for
textual representation of values.

Example use (Python):

>>> from vaucanswig_usual_context import *
>>> c = make_context(usual_alphabet_t("abc"))

>>> c.exp("a+b+c").describe()
'usual_exp_t@0x81a2e60 = ((a+b)+c)'

>>> (c.exp("a")*c.exp("a+b+c")).star().describe()
'usual_exp_t@0x81a20f8 = (a.((a+b)+c))*'

>>> from vaucanswig_tropical_min_context import *
>>> c = make_context(tropical_min_alphabet_t("abc"))

>>> c.series().identity().describe()
'tropical_min_serie_t@0x81ad8b8 = 0'
>>> c.series().zero().describe()
'tropical_min_serie_t@0x81a6de8 = +oo'

Automata
--------

The module vaucanswig_D_automaton contains:

* D_auto_t: the standard automaton type
* gen_D_auto_t: the generalized automaton type

These classes construct by copy or from a D_context.

For convenience purposes, a gen_D_auto_t can be constructed from a
D_auto_t (generalization). The opposite is not possible, of course.

In addition to the standard vaucanson methods, these classes have been
enriched with the following operators:

  describe()          // short description
  as_dot()            // textual representation in "dot" format
  dot_run(tmpf, cmd)  // run "cmd tmpf" after dumping to "tmpf"

Example use:

>>> from vaucanswig_usual_automaton import *
>>> a = usual_auto_t(c)
>>> a.add_state()
0
>>> a.add_state()
1
>>> a.add_state()
2
>>> a.del_state(1)
>>> for i in a.states():
...   print i
... 
0
2
>>> a.dot_run("tmp", "dot_view")
>>>

Algorithms
----------

As a general rule of thumb, if some algorithm 'foo' is defined in
vaucanson/algorithms/bar.hh, then:

- module vaucanswig_D_alg_bar contains 'foo'
- module vaucanswig_D_algorithms contains 'D.foo'

Adding algorithms
=================

You can add an algorithm to vaucanswig simply by adding
  // INTERFACE: ....
declarations in include/vaucanson/algorithms.

Example
-------

Let foo.hh a file in include/vaucanson/algorithms containing the
following code:

  // INTERFACE: Exp foo1(const Exp& other) { return vcsn::foo1(other); }
  template<typename S, typename T>
  Element<S, T> foo1(const Element<S, T>& exp);
  // INTERFACE: Exp foo1(const Exp& other1, const Exp& other2) { return vcsn::foo2(other1, other2); }
  template<typename S, typename T>
  Element<S, T> foo1(const Element<S, T>& exp);

Then, after running expand.sh for category D, the following module is
available:

   module vaucanswig_D_alg_foo 
       D_exp_t foo1(const D_exp_t&);
       D_exp_t foo2(const D_exp_t&, const D_exp_t);

And the special algorithm class 'D', defined in
vaucanswig_D_algorithms, now contains 'foo1' and 'foo2'.
  
Limitations
-----------

When writing "// INTERFACE:" comments, the following notes must be
taken into consideration:

- the comment must stand on a single line. 
  For the moment, expand.sh does not support multi-line interface
  declarations.

- the following special macro names are available:

     * Exp: the expression type for the category
     * Serie: the polynom/serie type for the category
     * Automaton: the automaton type
     * GenAutomaton: the generalized automaton type
     * HList: std::list<int>, used as a standard container

- when accessing automata, a special behavior stands. Instead of 
  writing:
 
    // INTERFACE: void foo(Automaton& a) { return vcsn::foo(a); }
    // INTERFACE: void foo(GenAutomaton& a) { return vcsn::foo(a); }

  one should write instead:

    // INTERFACE: void foo(Automaton& a) { return vcsn::foo(*a); }
    // INTERFACE: void foo(GenAutomaton& a) { return vcsn::foo(*a); }
    
  Indeed, "Automaton" and "GenAutomaton" do not expand to vaucanson
  automata types, but to a wrapper type. The real automaton can be
  reached by means of operator*().
