Background
==========

Vaucanswig is a set of SWIG wrapper definitions for the Vaucanson
library.

SWIG takes Vaucanswig as input, and generates code to link between
any supported scripting language and C++.

In that sense, Vaucanswig is already "meta", because it ultimately
supports several scripting languages.


But still, even Vaucanswig itself is automatically generated.


This document explains how to *use* Vaucanswig once it has been
generated.

See file "meta-build-process.txt" to learn about the internals
of Vaucanswig and how Vaucanswig itself is generated.


SWIG modules (MODULES)
======================

Vaucanswig defines a number of SWIG MODULES.

The list of SWIG modules contains:

 core 			- the core of vaucanswig.

 (K)_context		- for each K, the definition of the algebraic context
			  K ("K" can be "usual", "numerical", "tropical" and
			  so on)

 (K)_automaton		- definition of the Automaton and Expression
 			  types in context K

 (K)_alg_(A)		- for each algorithm A, the definition of the specific
 			  instance of A in context K.
			  ("A" can be "complete", "standard", "product" and so
			  on)

 (K)_algorithm		- a convienient wrapper for context K with "shortcuts"
 			  to all the algorithms instanciated for K.


Note that the name of SWIG modules are closely related to the namespace
where the corresponding features can be found in the target scripting language.

Then, for each module M, two items are available:

 src/vaucanswig_(M).i   - the dedicated SWIG source file

 src/(M).deps		- (optional, may not exist) a file containing a list
 			  of modules that M is dependent upon. If the file is
			  empty, two cases apply:
                                M is "core" - no dependency
				M is not "core" - it depends on "core".

The first item is the most important. The second is only useful to create
automated build processes which require dependency rules.


C++ sources specific to the target scripting language (TSL)
===========================================================

Each TSL needs a different set of wrapper for the Vaucanswig modules.

For any given TSL, source files for the MODULES can be created by SWIG by
running

 for each module ${M} (core, usual_context, usual_automaton, ...)

      $ ${SWIG} -noruntime -c++ -${TSL} \
         -I${VAUCANSWIGDIR}/src \
	 -I${VAUCANSWIGDIR}/meta \
	 -I${VAUCANSON_INCLUDES}  \
	 ${VAUCANSWIGDIR}/src/vaucanswig_${M}.i

  where:
    - ${TSL} is the SWIG option pertaining to the language (python, java ...)
    - ${VAUCANSWIGDIR} is the root directory of Vaucanswig.
    - ${SWIG} is the path to the SWIG binary.
    - ${VAUCANSON_INCLUDES} is the base directory of the Vaucanson library.

Compilation of the binaries for the target scripting language
=============================================================

The previous step creates a bunch of C++ source files of the form :

   vaucanswig_${M}_wrap.cxx

They should be compiled with the C++ compiler supported by the TSL.

The C++ compilation should use the following flags :

   -DINTERNAL_CHECKS -DSTRICT -DEXCEPTION_TRAPS
   			(for more secure code in Vaucanson)

   -I${VAUCANSON_INCLUDES}
                        (because it uses the Vaucanson library afterall)

   -I${VAUCANSWIGDIR}/src -I${VAUCANSWIGDIR}/meta
                        (additional includes from Vaucanswig needed)


   In addition, any "compatibility" flags required by Vaucanson for this
   particular C++ compiler should be used as well.


Automake support for Python as a TSL
====================================

According to the previous section, a Makefile.am file is generated
in the subdirectory python/ .

It contains four main parts.

   * A header:

      ##
      ## Set INCLUDES for compilation of C++ code.
      ##

      # FIXME: the python path is hardcoded, this is NOT good.
      INCLUDES = -I/usr/include/python2.2 \
                 -I$(srcdir)/../src -I$(srcdir)/../meta \
		 -I$(top_srcdir)/include -I$(top_builddir)/include

      ##
      ## Set AM_... flags.
      ##

      # According to spec.
      AM_CPPFLAGS = -DINTERNAL_CHECKS -DSTRICT -DEXCEPTION_TRAPS
      # We want lots of debugging information in the wrapper code.
      AM_CXXFLAGS = $(CXXFLAGS_DEBUG)
      # For Libtool, to generate dynamically loadable modules.
      AM_LDFLAGS = -module -avoid-version

   * List of binary targets (the shared objects - DLL).

      For each MODULE:

        pyexec_LTLIBRARIES += libvs_(module name).la

   * List of Python source files.

      For each MODULE:

        python_PYTHON += vaucanswig_(module name).py

   * Build specifications binary targets.

      For each MODULE:

        libvs_(module name)_la_SOURCES = vaucanswig_(module name)_wrap.cxx

	If the module is "core":

	   # This should be the only dependency against static, non-template
	   # Vaucanswig code. And make it a dependency to the SWIG runtime.
	   libvs_core_la_LIBADD = ../meta/libvv.la -lswigpy

        Else:

	   If src/(module name).deps is empty:

	      libvs_(module name)_la_LIBADD = libvs_core.la

	   Else for each name in src/(module name).deps do:

	      libvs_(module name)_la_LIBADD += libvs_(dependency name).la


Additionnaly, the following (not important) parts are generated for
convenience purposes:

    * Rules to rerun SWIG in case something changes in Vaucanswig.

         vaucanswig_*_wrap.cxx vaucanswig_*.py: ../src/vaucanswig_*.i
	       $(SWIG) -noruntime -c++ -python -I... \
	               -o vaucanswig_*_wrap.cxx \
		       ../src/vaucanswig_*.i

    * Installation and Uninstallation hooks.


Automake support for the TSL-independent code
=============================================

In order to make things comply to the spirit of the Autotools,
a convenience Makefile.am is generated in the src/ directory.

It contains a definition of EXTRA_DIST with all the SWIG module
source files, of the form: vaucanswig_(M).i



